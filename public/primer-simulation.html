<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circulation &amp; Production — Toy Model</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Georgia', serif;
    background: #0d1117;
    color: #e6edf3;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* ── Header ── */
  header {
    padding: 12px 24px;
    border-bottom: 1px solid #21262d;
    display: flex;
    align-items: center;
    gap: 16px;
    flex-shrink: 0;
  }
  header h1 { font-size: 24px; color: #f0f6fc; font-weight: 600; }
  header .subtitle { font-size: 15px; color: #b1bac4; }
  .mode-badge {
    margin-left: auto;
    padding: 5px 16px;
    border-radius: 14px;
    font-size: 15px;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  .mode-badge.cc  { background: #0d419d; color: #79c0ff; }
  .mode-badge.capital { background: #5b0d5b; color: #d2a8ff; }

  /* ── Main grid ── */
  .main-grid {
    flex: 1;
    display: grid;
    grid-template-columns: 280px 1fr;
    grid-template-rows: 1fr;
    overflow: hidden;
  }

  /* ── Left sidebar ── */
  .sidebar {
    padding: 16px;
    border-right: 1px solid #21262d;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 14px;
    font-size: 15px;
  }
  .group { display: flex; flex-direction: column; gap: 5px; }
  .group-label {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #b1bac4;
    font-weight: 600;
  }
  .group .desc { font-size: 14px; color: #8b949e; line-height: 1.4; }
  .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
  button {
    padding: 8px 16px;
    border: 1px solid #30363d;
    border-radius: 6px;
    background: #21262d;
    color: #e6edf3;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  button:hover { background: #30363d; border-color: #484f58; }
  button.primary { background: #238636; border-color: #2ea043; color: #fff; }
  button.primary:hover { background: #2ea043; }
  button.warn { background: #8b1538; border-color: #da3633; color:#fff; }
  button.warn:hover { background: #b62324; }
  button.active { background: #1f6feb; border-color: #388bfd; color: #fff; }
  input[type="range"] { width: 100%; accent-color: #388bfd; }

  .stat-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 3px 0; font-size: 15px;
  }
  .stat-value {
    font-variant-numeric: tabular-nums;
    color: #f0f6fc; font-weight: 700;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 15px;
  }
  .divider { border-top: 1px solid #21262d; margin: 4px 0; }

  /* ── Right: canvas + chart ── */
  .canvas-col {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }

  /* Circulation canvas takes ~65% */
  .circ-wrap {
    flex: 7;
    position: relative;
    min-height: 0;
  }
  #world { display: block; width: 100%; height: 100%; }

  /* Chart strip at bottom */
  .chart-strip {
    flex: 5;
    min-height: 220px;
    border-top: 1px solid #21262d;
    position: relative;
    background: #0d1117;
  }
  #chart { display: block; width: 100%; height: 100%; }

  /* Legend bar between them */
  .legend-bar {
    display: flex;
    gap: 20px;
    padding: 6px 20px;
    border-top: 1px solid #21262d;
    font-size: 14px;
    color: #b1bac4;
    flex-shrink: 0;
    flex-wrap: wrap;
    background: #0d1117;
  }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

  /* Floating log overlay */
  .log-overlay {
    position: absolute;
    top: 8px; right: 8px;
    width: 320px;
    max-height: 45%;
    background: #0d1117ee;
    border: 1px solid #21262d;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-size: 12px;
    z-index: 10;
  }
  .log-overlay.collapsed .log-entries { display: none; }
  .log-hdr {
    padding: 6px 12px;
    border-bottom: 1px solid #21262d;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #b1bac4;
    cursor: pointer;
    display: flex; justify-content: space-between; align-items: center;
    user-select: none;
  }
  .log-entries {
    overflow-y: auto;
    padding: 4px 10px;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 13px;
    line-height: 1.5;
  }
  .log-entry { padding: 2px 0; border-bottom: 1px solid #161b2288; }
  .log-entry .time { color: #6e7681; margin-right: 4px; }
  .log-entry.exchange { color: #79c0ff; }
  .log-entry.production { color: #56d364; }
  .log-entry.depletion { color: #f0883e; }
  .log-entry.capital { color: #d2a8ff; }
  .log-entry.system  { color: #b1bac4; }

  /* Technology matrix */
  .tech-matrix {
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 12px;
    line-height: 1.55;
    max-height: 200px;
    overflow-y: auto;
  }
  .tech-row {
    display: flex;
    align-items: baseline;
    gap: 4px;
    padding: 2px 0;
    border-bottom: 1px solid #161b2244;
  }
  .tech-out {
    font-weight: 700;
    min-width: 32px;
  }
  .tech-arrow { color: #6e7681; }
  .tech-coeff {
    color: #b1bac4;
  }
  .tech-coeff .sym { font-weight: 600; }
  .tech-count { color: #6e7681; font-size: 11px; margin-left: auto; }

  /* Editable technology matrix */
  .tech-edit-row {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 3px 0;
    border-bottom: 1px solid #161b2244;
    flex-wrap: wrap;
  }
  .tech-edit-row select, .tech-edit-row input[type="number"] {
    background: #161b22;
    border: 1px solid #30363d;
    color: #e6edf3;
    border-radius: 4px;
    padding: 2px 3px;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 11px;
  }
  .tech-edit-row select { width: 100px; }
  .tech-edit-row input[type="number"] { width: 88px; }
  .tech-edit-row .btn-remove {
    background: none;
    border: none;
    color: #da3633;
    cursor: pointer;
    font-size: 13px;
    padding: 0 3px;
    line-height: 1;
  }
  .tech-edit-row .btn-remove:hover { color: #ff6b6b; }
  .tech-edit-row .btn-remove:disabled { color: #30363d; cursor: default; }
  .btn-add-commodity {
    margin-top: 6px;
    padding: 4px 10px;
    font-size: 12px;
  }
  .tech-edit-sym {
    font-weight: 700;
    min-width: 24px;
    text-align: center;
  }
  .tech-edit-arrow {
    color: #6e7681;
    font-size: 11px;
  }
  .tech-edit-plus {
    color: #6e7681;
    font-size: 10px;
  }
  .tech-col-sum-warn {
    color: #da3633;
    font-weight: 700;
  }

  /* Modal */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .modal-overlay.hidden { display: none; }
  .modal {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 12px;
    padding: 24px;
    max-width: 560px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }
  .modal-header h2 {
    font-size: 18px;
    color: #f0f6fc;
    font-weight: 600;
  }
  .modal-close {
    background: none;
    border: none;
    color: #8b949e;
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
  }
  .modal-close:hover { color: #f0f6fc; }

  /* Collapsible sidebar sections */
  .collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
    padding: 2px 0;
  }
  .collapsible-header:hover .collapse-arrow { color: #e6edf3; }
  .collapse-arrow {
    font-size: 11px;
    color: #6e7681;
    transition: transform 0.2s, color 0.15s;
    flex-shrink: 0;
  }
  .collapsible-body {
    display: flex;
    flex-direction: column;
    gap: 5px;
    overflow: hidden;
    transition: max-height 0.25s ease, opacity 0.2s ease;
    max-height: 600px;
    opacity: 1;
  }
  .section-collapsed .collapsible-body {
    max-height: 0;
    opacity: 0;
    pointer-events: none;
  }
  .section-collapsed .collapse-arrow {
    transform: rotate(-90deg);
  }

  /* Production recipe callout (shown on canvas) */
  .recipe-toast {
    position: absolute;
    left: 50%; bottom: 12px;
    transform: translateX(-50%);
    background: #0a3d1cdd;
    border: 1px solid #3fb950;
    border-radius: 8px;
    padding: 10px 18px;
    font-size: 16px;
    color: #56d364;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 5;
    white-space: nowrap;
    font-family: 'SF Mono','Consolas',monospace;
  }
  .recipe-toast.visible { opacity: 1; }
</style>
</head>
<body>

<header>
  <h1>Circulation &amp; Production</h1>
  <span class="subtitle">Toy model — Primer §9-11</span>
  <div class="mode-badge cc" id="modeBadge">CC — Simple Circulation</div>
</header>

<div class="main-grid">
  <!-- ── Sidebar ── -->
  <div class="sidebar">
    <div class="group">
      <div class="group-label">Mode</div>
      <div class="btn-row">
        <button id="btn-mode-cc" class="active" onclick="setMode('cc')">CC (Simple)</button>
        <button id="btn-mode-capital" onclick="setMode('capital')">Capital</button>
      </div>
      <div class="desc" id="mode-desc">Stabilized commodity region: circulation + value-conserving production. §9.14</div>
    </div>

    <div class="divider"></div>

    <div class="group">
      <div class="group-label">Simulation</div>
      <div class="btn-row">
        <button class="primary" id="btn-play" onclick="togglePlay()">&#x25B6; Play</button>
        <button onclick="stepOnce()">Step</button>
        <button class="warn" onclick="resetSim()">Reset</button>
      </div>
    </div>

    <div class="group">
      <div class="group-label">Speed</div>
      <input type="range" id="speed" min="1" max="20" value="5">
    </div>

    <div class="group">
      <div class="group-label">Proprietors &mdash; <span id="prop-count">6</span></div>
      <input type="range" id="numProprietors" min="3" max="12" value="6" oninput="document.getElementById('prop-count').textContent=this.value" onchange="resetSim()">
    </div>

    <div class="group">
      <div class="group-label">Init. goods each &mdash; <span id="comm-count">3</span></div>
      <input type="range" id="initCommodities" min="1" max="8" value="3" oninput="document.getElementById('comm-count').textContent=this.value" onchange="resetSim()">
    </div>

    <div class="divider"></div>

    <!-- 1. Statistics (expanded by default) -->
    <div class="group" id="section-stats">
      <div class="collapsible-header" onclick="toggleSection('section-stats')">
        <div class="group-label">Statistics &mdash; t = <span id="stat-tick">0</span></div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="stat-row"><span>Goods |G|</span><span class="stat-value" id="stat-G">0</span></div>
        <div class="stat-row"><span>Total money M</span><span class="stat-value" id="stat-Mcirc">0</span></div>
        <div class="stat-row"><span>Total value V</span><span class="stat-value" id="stat-Mtotal">0</span></div>
        <div class="stat-row"><span>Exchanges</span><span class="stat-value" id="stat-exchanges">0</span></div>
        <div class="stat-row"><span>Productions</span><span class="stat-value" id="stat-productions">0</span></div>
        <div class="stat-row"><span>Surplus &delta;</span><span class="stat-value" id="stat-surplus">0</span></div>
        <div class="stat-row"><span>Labor surplus s</span><span class="stat-value" id="stat-surplus-labor">0</span></div>
      </div>
    </div>

    <div class="divider"></div>

    <!-- 2. Production (collapsed by default) -->
    <div class="group section-collapsed" id="section-production">
      <div class="collapsible-header" onclick="toggleSection('section-production')">
        <div class="group-label">Production (Stabilizer)</div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="btn-row">
          <button id="btn-prod-off" onclick="setProd('off')">Off</button>
          <button id="btn-prod-conservative" class="active" onclick="setProd('conservative')">On (Leontief)</button>
        </div>
        <div class="desc" id="prod-desc">Value-conserving: U(outputs) = U(inputs). The stabilizer couples production to circulation so G is replenished. §9.12&ndash;9.14</div>
      </div>
    </div>

    <div class="divider"></div>

    <!-- 2b. Exchange-Consumption Coupling -->
    <div class="group" id="section-coupling">
      <div class="group-label">Exchange &harr; Consumption</div>
      <div class="btn-row">
        <button id="btn-couple-on" class="active" onclick="setCoupling(true)">Coupled</button>
        <button id="btn-couple-off" onclick="setCoupling(false)">Independent</button>
      </div>
      <div class="desc" id="coupling-desc">Each exchange triggers consumption: buying drives using.</div>
    </div>

    <div class="divider"></div>

    <!-- 3. Labor (collapsed by default) -->
    <div class="group section-collapsed" id="section-labor">
      <div class="collapsible-header" onclick="toggleSection('section-labor')">
        <div class="group-label">Labor</div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="btn-row">
          <button id="btn-labor-implicit" class="active" onclick="setLabor('implicit')">Implicit (self)</button>
          <button id="btn-labor-commodity" onclick="setLabor('commodity')">Commodity (t<sub>r</sub>)</button>
        </div>
        <div class="desc" id="labor-desc">Each producer adds their own labor. No money exchanged for labor.</div>
        <div class="group" id="labor-slider-group" style="display:none;flex-direction:column;gap:4px;margin-top:6px;">
          <div class="group-label" style="font-size:13px;">
            t<sub>r</sub> / value-added &mdash; <span id="tr-pct">100</span>%
          </div>
          <input type="range" id="trSlider" min="50" max="100" value="100" step="5"
                 oninput="updateTrSlider()" style="width:100%;accent-color:#3fb950;" />
          <div class="desc" id="tr-desc">Simple reproduction: t&#7523; = value-added, no surplus (s=0).</div>
        </div>
      </div>
    </div>

    <div class="divider"></div>

    <!-- 4. Leontief Technology A -->
    <div class="group">
      <div class="group-label">Leontief Technology A</div>
      <div class="desc" id="leontief-summary"></div>
      <button onclick="openLeontiefEditor()">Edit Matrix</button>
    </div>
  </div>

  <!-- ── Canvas column ── -->
  <div class="canvas-col">

    <div class="circ-wrap">
      <canvas id="world"></canvas>
      <!-- Floating log -->
      <div class="log-overlay" id="logOverlay">
        <div class="log-hdr" onclick="toggleLog()">
          <span>Transaction Log</span>
          <span id="logToggle">&#x25BC;</span>
        </div>
        <div class="log-entries" id="log"></div>
      </div>
      <!-- Recipe toast -->
      <div class="recipe-toast" id="recipeToast"></div>
    </div>

    <div class="legend-bar">
      <div class="legend-item"><div class="legend-dot" style="background:#58a6ff"></div> Money</div>
      <div class="legend-item"><div class="legend-dot" style="background:#f0883e"></div> Commodity</div>
      <div class="legend-item"><div class="legend-dot" style="background:#3fb950"></div> Production</div>
      <div class="legend-item"><div class="legend-dot" style="background:#d2a8ff"></div> Capital &gamma;</div>
      <div class="legend-item"><div class="legend-dot" style="background:#da3633"></div> Consumption</div>
      <div class="legend-item" style="margin-left:auto;color:#6e7681">
        Stabilizer P: production replenishes what circulation consumes (§9.14)
      </div>
    </div>

    <div class="chart-strip">
      <canvas id="chart"></canvas>
    </div>
  </div>
</div>

<!-- Leontief Editor Modal -->
<div class="modal-overlay hidden" id="leontiefModal" onclick="if(event.target===this)closeLeontiefEditor()">
  <div class="modal">
    <div class="modal-header">
      <h2>Leontief Technology Matrix</h2>
      <button class="modal-close" onclick="closeLeontiefEditor()">&times;</button>
    </div>
    <div class="desc" style="margin-bottom:14px;font-size:14px;">
      Edit input coefficients and commodities. Column sums &lt; 1 &rArr; productive economy.
    </div>
    <div class="tech-matrix" id="techMatrix"></div>
  </div>
</div>

<script>
// ============================================================
// TOY MODEL: CC, Depletion, Stabilizer, Capital
// Continuous-quantity model (fractional goods, Leontief I/O)
// ============================================================

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chart');
const chartCtx = chartCanvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

// ── Constants ──
const UNIT_PRICE = 5;
const EXCHANGE_QTY_MIN = 0.3;
const EXCHANGE_QTY_MAX = 0.8;
const CONSUME_QTY_MIN = 0.05;
const CONSUME_QTY_MAX = 0.15;
const PROD_SCALE_MAX = 1.5;
const DEATH_THRESHOLD = 0.01;

// ── State ──
let mode = 'cc';
let prodMode = 'conservative';
let playing = false;
let tick = 0;
let exchangeCount = 0;
let productionCount = 0;
let surplusAccumulated = 0;
let proprietors = [];
let animations = [];
let gHistory = [];
let vHistory = [];
let mHistory = [];
let exchPerTickHistory = [];
let prodPerTickHistory = [];
let consPerTickHistory = [];
let recipeTimer = 0;
let targetG = 0; // Leontief equilibrium target for |G|
let laborMode = 'implicit'; // 'implicit' | 'commodity'
let trRatio = 1.0;          // t_r / value_added, from slider (0.1 to 1.0)
let surplusLabor = 0;       // cumulative surplus s from production
let coupleExchangeConsumption = true;  // couple exchange with consumption
let currentConsRate = 0.055;           // updated each step by stabilizer
let stepConsumedQty = 0;              // total units consumed this step (coupled mode)

// ── Commodity types (sectors) ──
let TYPES = [
  { name:'wheat', color:'#f0883e', sym:'W' },
  { name:'cloth', color:'#e06c75', sym:'Cl'},
  { name:'iron',  color:'#9ea5b0', sym:'Fe'},
  { name:'wine',  color:'#bc8cff', sym:'Vi'},
  { name:'wood',  color:'#a67c52', sym:'Wd'},
  { name:'salt',  color:'#d0d0d0', sym:'Sa'},
  { name:'fish',  color:'#56d4dd', sym:'Fi'},
  { name:'bread', color:'#d4a76a', sym:'Br'},
];
let N_SECTORS = TYPES.length;

// Pool of extra commodities for the "Add" button
const COMMODITY_POOL = [
  { name:'coal',   sym:'Co', color:'#777777' },
  { name:'gold',   sym:'Au', color:'#ffd700' },
  { name:'silk',   sym:'Si', color:'#ff69b4' },
  { name:'oil',    sym:'Oi', color:'#4a7a3a' },
  { name:'corn',   sym:'Cn', color:'#e8d44d' },
  { name:'copper', sym:'Cu', color:'#b87333' },
  { name:'tea',    sym:'Te', color:'#567d46' },
  { name:'tin',    sym:'Sn', color:'#8b8b83' },
  { name:'sugar',  sym:'Su', color:'#f5f5dc' },
  { name:'lime',   sym:'Li', color:'#32cd32' },
];

// ═══════════════════════════════════════════════════════════════
// LEONTIEF INPUT–OUTPUT SYSTEM
// One canonical recipe per sector. Each takes 2 inputs → 1 output.
// The economy is fully circular: every good is both produced and consumed.
// ═══════════════════════════════════════════════════════════════
let LEONTIEF_RECIPES = [
  { output:'W',  inputs:['Br','Fi'], coeffs:[0.4,0.4] },
  { output:'Cl', inputs:['Fe','Wd'], coeffs:[0.4,0.4] },
  { output:'Fe', inputs:['Wd','Sa'], coeffs:[0.4,0.4] },
  { output:'Vi', inputs:['W','Wd'],  coeffs:[0.4,0.4] },
  { output:'Wd', inputs:['Br','Fe'], coeffs:[0.4,0.4] },
  { output:'Sa', inputs:['Cl','Vi'], coeffs:[0.4,0.4] },
  { output:'Fi', inputs:['Wd','W'],  coeffs:[0.4,0.4] },
  { output:'Br', inputs:['W','Sa'],  coeffs:[0.4,0.4] },
];

function recipeLabel(r){ return r.inputs.join('+') + ' \u2192 ' + r.output; }

// Technology matrix A[i][j] = input coefficient of good i per unit of good j produced.
let LEONTIEF_A = [];
let LEONTIEF_INV = [];
let LEONTIEF_X_STAR = [];
let PROD_WEIGHTS = [];

// Compute (I−A)⁻¹ via Gauss-Jordan elimination
function invertIminusA(A){
  const n=A.length;
  if(n===0) return [];
  const aug=A.map((row,i)=>{
    const r=row.map((v,j)=>(i===j?1:0)-v);
    return [...r,...Array(n).fill(0).map((_,j)=>i===j?1:0)];
  });
  for(let c=0;c<n;c++){
    let mx=c;
    for(let r=c+1;r<n;r++) if(Math.abs(aug[r][c])>Math.abs(aug[mx][c])) mx=r;
    [aug[c],aug[mx]]=[aug[mx],aug[c]];
    const piv=aug[c][c];
    if(Math.abs(piv)<1e-12) continue; // singular guard
    for(let j=0;j<2*n;j++) aug[c][j]/=piv;
    for(let r=0;r<n;r++){
      if(r===c)continue;
      const f=aug[r][c];
      for(let j=0;j<2*n;j++) aug[r][j]-=f*aug[c][j];
    }
  }
  return aug.map(row=>row.slice(n));
}

// Rebuild all derived Leontief structures from TYPES + LEONTIEF_RECIPES
function rebuildLeontief(){
  N_SECTORS = TYPES.length;
  // Build A matrix from recipes
  LEONTIEF_A = Array.from({length:N_SECTORS}, ()=>Array(N_SECTORS).fill(0));
  for (const r of LEONTIEF_RECIPES){
    const j = TYPES.findIndex(t=>t.sym===r.output);
    if(j<0) continue;
    for (let k=0; k<r.inputs.length; k++){
      const i = TYPES.findIndex(t=>t.sym===r.inputs[k]);
      if(i>=0) LEONTIEF_A[i][j] = r.coeffs[k];
    }
  }
  // Compute inverse
  LEONTIEF_INV = invertIminusA(LEONTIEF_A);
  // Equilibrium gross output for uniform demand d=[1,...,1]
  const d = Array(N_SECTORS).fill(1);
  LEONTIEF_X_STAR = LEONTIEF_INV.map(row=>row.reduce((s,v,j)=>s+v*d[j],0));
  const xSum = LEONTIEF_X_STAR.reduce((s,v)=>s+v,0);
  PROD_WEIGHTS = xSum>0 ? LEONTIEF_X_STAR.map(v=>v/xSum) : Array(N_SECTORS).fill(1/N_SECTORS);
  // Update displays
  renderEditableMatrix();
  updateLeontiefSummary();
}

function typeBySymbol(s) { return TYPES.find(t => t.sym === s); }

// ── Proprietor (continuous inventory) ──
class Proprietor {
  constructor(id, x, y) {
    this.id = id;
    this.name = `O\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089`[id+1] ? `O${String.fromCharCode(0x2080+id+1)}` : `O${id+1}`;
    this.label = `O${id+1}`;
    this.x = x; this.y = y;
    this.money = 0;
    this.inventory = {}; // sym → quantity (continuous)
    this.role = 'idle';
    this.roleTimer = 0;
    this.isCapitalist = false;
    this.capitalSurplus = 0;
    this.dead = false;
  }
  totalGoods() {
    return Object.values(this.inventory).reduce((s, q) => s + q, 0);
  }
  addGoods(sym, qty) {
    this.inventory[sym] = (this.inventory[sym] || 0) + qty;
  }
  removeGoods(sym, qty) {
    if (!this.inventory[sym]) return 0;
    const removed = Math.min(this.inventory[sym], qty);
    this.inventory[sym] -= removed;
    if (this.inventory[sym] < DEATH_THRESHOLD) delete this.inventory[sym];
    return removed;
  }
  randomGoodType() {
    const entries = Object.entries(this.inventory).filter(([_, q]) => q > DEATH_THRESHOLD);
    if (!entries.length) return null;
    const total = entries.reduce((s, [_, q]) => s + q, 0);
    let r = Math.random() * total;
    for (const [sym, qty] of entries) {
      r -= qty;
      if (r <= 0) return sym;
    }
    return entries[entries.length - 1][0];
  }
  totalValue() {
    return this.money + this.totalGoods() * UNIT_PRICE;
  }
  checkDeath() {
    if (!this.dead && this.money < DEATH_THRESHOLD && this.totalGoods() < DEATH_THRESHOLD) {
      if (laborMode === 'commodity') return; // can still work for wages
      this.dead = true;
      this.role = 'dead';
      logEntry('system',`\uD83D\uDC80 ${this.label} eliminated \u2014 no money, no goods.`);
    }
  }
}

// ── Init ──
function init() {
  const n = +document.getElementById('numProprietors').value;
  const initC = +document.getElementById('initCommodities').value;
  proprietors = []; animations = [];
  tick=0; exchangeCount=0; productionCount=0; surplusAccumulated=0; surplusLabor=0;
  gHistory=[]; vHistory=[]; mHistory=[];
  exchPerTickHistory=[]; prodPerTickHistory=[]; consPerTickHistory=[];

  const cx = canvas.width/(2*DPR);
  const cy = canvas.height/(2*DPR);
  const radius = Math.min(cx,cy)*0.73;

  for (let i=0;i<n;i++){
    const a = 2*Math.PI*i/n - Math.PI/2;
    const p = new Proprietor(i, cx+radius*Math.cos(a), cy+radius*Math.sin(a));
    p.money = 12+Math.floor(Math.random()*8);
    // Distribute initC total units across random types
    let remaining = initC;
    while (remaining > 0.01) {
      const sym = TYPES[Math.floor(Math.random()*TYPES.length)].sym;
      const chunk = Math.min(remaining, 0.3 + Math.random()*1.2);
      p.addGoods(sym, chunk);
      remaining -= chunk;
    }
    if (mode==='capital' && i===0){ p.isCapitalist=true; p.money=40; }
    proprietors.push(p);
  }

  // Set Leontief target: |G| should stay at this level in conservative mode
  targetG = proprietors.reduce((s,p)=>s+p.totalGoods(), 0);

  logEntry('system',`Init ${n} proprietors, mode=${mode}, prod=${prodMode}, target |G|=${targetG.toFixed(1)}`);
  updateStats();
}

// ── Exchange helper (extracted so coupled mode can reorder) ──
function runExchanges(shuffled){
  for (const p of shuffled){
    p.roleTimer = Math.max(0, p.roleTimer-1);
    if (p.roleTimer>0) continue;
    if (mode==='capital' && p.isCapitalist){ attemptCapital(p); continue; }
    if (p.money>0 && Math.random()<0.5) attemptBuy(p);
    else if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<0.4) attemptSell(p);
  }
}

// ── Simulation step ──
function step(){
  // Check depletion — halt if G≈0
  const Gpre = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (Gpre<DEATH_THRESHOLD){
    if (playing){
      playing=false;
      document.getElementById('btn-play').innerHTML='\u25B6 Play';
      document.getElementById('btn-play').className='primary';
      logEntry('system','\u26A0 G\u22480 \u2014 circulation halted (depletion). \u00A79.10.4');
    }
    return;
  }

  tick++;
  stepConsumedQty = 0;
  const exchBefore = exchangeCount;
  const prodBefore = productionCount;
  const alive = proprietors.filter(p=>!p.dead);
  const shuffled = [...alive].sort(()=>Math.random()-0.5);

  if (coupleExchangeConsumption) {
    // ═══════════════════════════════════════════════════════════
    // COUPLED: Exchange first (drives consumption), then production matches
    // ═══════════════════════════════════════════════════════════

    // Stabilizer: adjust consumption probability based on |G| drift
    const drift = Gpre - targetG;
    currentConsRate = Math.min(0.85, Math.max(0.15, 0.5 + drift*0.02));

    // 1. Exchanges (probabilistic consumption → stepConsumedQty tracked)
    runExchanges(shuffled);

    // 2. Production: match consumption. Each production event nets
    //    scale*(1-colSum) units. Poorest-first so wealth doesn't concentrate.
    if (prodMode!=='off' && stepConsumedQty>DEATH_THRESHOLD){
      let netProduced = 0;
      const target = stepConsumedQty;
      // Sort by ascending goods — poorest produce first
      const prodOrder = [...shuffled].sort((a,b) => a.totalGoods() - b.totalGoods());
      for (const p of prodOrder){
        if (netProduced>=target) break;
        const remaining = target - netProduced;
        const goodsBefore = p.totalGoods();
        if (attemptLeontief(p, remaining)) {
          netProduced += p.totalGoods() - goodsBefore;
        }
      }
    }

  } else {
    // ═══════════════════════════════════════════════════════════
    // INDEPENDENT: Production+Consumption first, then exchanges
    // ═══════════════════════════════════════════════════════════
    if (prodMode==='off'){
      consumeGoods(alive, 0.07);
    } else {
      // ── LEONTIEF STABILIZER (§9.12–9.14) ──
      const drift = Gpre - targetG;
      const consRate = Math.min(0.12, Math.max(0, 0.055 + drift*0.015));
      const prodRate = Math.min(0.12, Math.max(0, 0.055 - drift*0.015));
      currentConsRate = consRate;
      for (const p of shuffled){
        if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<prodRate)
          attemptLeontief(p);
      }
      consumeGoods(alive, consRate);
    }
    runExchanges(shuffled);
  }

  // ── Death check ──
  for (const p of alive) p.checkDeath();

  // Record
  gHistory.push(proprietors.reduce((s,p)=>s+p.totalGoods(),0));
  const V = proprietors.reduce((s,p)=>s+p.totalValue(),0);
  vHistory.push(V);
  mHistory.push(proprietors.reduce((s,p)=>s+p.money,0));
  exchPerTickHistory.push(exchangeCount - exchBefore);
  prodPerTickHistory.push(productionCount - prodBefore);
  consPerTickHistory.push(stepConsumedQty);
  recipeTimer = Math.max(0, recipeTimer-1);
  if (recipeTimer===0) document.getElementById('recipeToast').classList.remove('visible');
  updateStats();
}

// ── Consumption helper ──
function consumeGoods(props, rate){
  for (const p of props){
    if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<rate){
      const sym = p.randomGoodType();
      if (!sym) continue;
      const qty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        p.inventory[sym] || 0
      );
      if (qty < DEATH_THRESHOLD) continue;
      p.removeGoods(sym, qty);
      const ctype = typeBySymbol(sym);
      animations.push({type:'consume', x:p.x, y:p.y, progress:0, color:ctype?.color||'#da3633'});
      logEntry('depletion',`${p.label} consumed ${qty.toFixed(2)} ${sym}`);
      stepConsumedQty += qty;
    }
  }
}

function attemptBuy(buyer){
  if (buyer.dead) return;
  const sellers = proprietors.filter(p=>p!==buyer && !p.dead && p.totalGoods()>DEATH_THRESHOLD);
  if (!sellers.length) return;
  const seller = sellers[Math.floor(Math.random()*sellers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  // Random exchange quantity, capped by seller's available and buyer's money
  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  qty = Math.min(qty, buyer.money / UNIT_PRICE);
  if (qty < DEATH_THRESHOLD) return;
  const price = qty * UNIT_PRICE;

  seller.removeGoods(sym, qty);
  buyer.addGoods(sym, qty);
  buyer.money -= price;
  seller.money += price;
  buyer.role='buyer'; buyer.roleTimer=6;
  seller.role='seller'; seller.roleTimer=6;
  exchangeCount++;

  addExchangeAnim(buyer, seller, sym, qty, price);
  logEntry('exchange',`${seller.label} \u2194 ${buyer.label}: ${qty.toFixed(2)} ${sym} @ ${price.toFixed(1)}`);

  // Coupled consumption: buying triggers consuming a fraction of buyer's goods
  if (coupleExchangeConsumption && Math.random()<currentConsRate && buyer.totalGoods()>DEATH_THRESHOLD) {
    const csym = buyer.randomGoodType();
    if (csym) {
      const cqty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        buyer.inventory[csym] || 0
      );
      if (cqty > DEATH_THRESHOLD) {
        buyer.removeGoods(csym, cqty);
        const ctype = typeBySymbol(csym);
        animations.push({type:'consume', x:buyer.x, y:buyer.y, progress:0, color:ctype?.color||'#da3633'});
        logEntry('depletion',`${buyer.label} consumed ${cqty.toFixed(2)} ${csym}`);
        stepConsumedQty += cqty;
      }
    }
  }
}

function attemptSell(seller){
  if (seller.dead) return;
  const buyers = proprietors.filter(p=>p!==seller && !p.dead && p.money>0);
  if (!buyers.length) return;
  const buyer = buyers[Math.floor(Math.random()*buyers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  // Random exchange quantity, capped by seller's available and buyer's money
  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  qty = Math.min(qty, buyer.money / UNIT_PRICE);
  if (qty < DEATH_THRESHOLD) return;
  const price = qty * UNIT_PRICE;

  seller.removeGoods(sym, qty);
  buyer.addGoods(sym, qty);
  buyer.money -= price;
  seller.money += price;
  buyer.role='buyer'; buyer.roleTimer=6;
  seller.role='seller'; seller.roleTimer=6;
  exchangeCount++;

  addExchangeAnim(buyer, seller, sym, qty, price);
  logEntry('exchange',`${seller.label} \u2194 ${buyer.label}: ${qty.toFixed(2)} ${sym} @ ${price.toFixed(1)}`);

  // Coupled consumption: buying triggers consuming a fraction of buyer's goods
  if (coupleExchangeConsumption && Math.random()<currentConsRate && buyer.totalGoods()>DEATH_THRESHOLD) {
    const csym = buyer.randomGoodType();
    if (csym) {
      const cqty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        buyer.inventory[csym] || 0
      );
      if (cqty > DEATH_THRESHOLD) {
        buyer.removeGoods(csym, cqty);
        const ctype = typeBySymbol(csym);
        animations.push({type:'consume', x:buyer.x, y:buyer.y, progress:0, color:ctype?.color||'#da3633'});
        logEntry('depletion',`${buyer.label} consumed ${cqty.toFixed(2)} ${csym}`);
        stepConsumedQty += cqty;
      }
    }
  }
}

// ── Leontief production (continuous) ──
// Try all recipes (weighted-shuffled) until one matches inputs. Returns boolean.
// Produces scale units of output consuming scale*coeff_i of each input.
// Net change to |G|: scale*(1-colSum) > 0 (labor's contribution).
// maxNetQty: if provided, cap scale so net output doesn't exceed this.
function attemptLeontief(producer, maxNetQty){
  if (producer.dead) return false;

  // Try recipes in weighted-shuffled order (biased toward equilibrium)
  const indices = Array.from({length:N_SECTORS}, (_,i)=>i);
  indices.sort((a,b)=>(Math.random()/(PROD_WEIGHTS[a]||0.01))-(Math.random()/(PROD_WEIGHTS[b]||0.01)));

  let chosen = null, maxScale = 0;
  for (const k of indices){
    const recipe = LEONTIEF_RECIPES[k];
    if (!recipe) continue;
    // Aggregate required amounts per input type (handles duplicate inputs)
    const required = {};
    for (let i = 0; i < recipe.inputs.length; i++){
      required[recipe.inputs[i]] = (required[recipe.inputs[i]] || 0) + recipe.coeffs[i];
    }
    // Compute max scale = min(available / totalCoeff) across input types
    let minRatio = Infinity;
    let canDo = true;
    for (const [sym, totalCoeff] of Object.entries(required)){
      const avail = producer.inventory[sym] || 0;
      if (avail < DEATH_THRESHOLD){ canDo=false; break; }
      minRatio = Math.min(minRatio, avail / totalCoeff);
    }
    if (!canDo || minRatio < DEATH_THRESHOLD) continue;
    chosen = recipe;
    maxScale = Math.min(minRatio, PROD_SCALE_MAX);
    break;
  }
  if (!chosen || maxScale < DEATH_THRESHOLD) return false;

  const colSum = chosen.coeffs.reduce((s, c) => s + c, 0);

  // Cap scale so net production (scale*(1-colSum)) doesn't overshoot budget
  let scale = maxScale;
  if (maxNetQty !== undefined) {
    const netPerUnit = 1 - colSum;
    if (netPerUnit > DEATH_THRESHOLD) {
      scale = Math.min(scale, maxNetQty / netPerUnit);
    }
  }
  if (scale < DEATH_THRESHOLD) return false;

  // Consume inputs
  const inputQtys = {};
  const required = {};
  for (let i = 0; i < chosen.inputs.length; i++){
    required[chosen.inputs[i]] = (required[chosen.inputs[i]] || 0) + chosen.coeffs[i];
  }
  for (const [sym, totalCoeff] of Object.entries(required)){
    const qty = scale * totalCoeff;
    producer.removeGoods(sym, qty);
    inputQtys[sym] = qty;
  }

  // Produce output
  const outSym = chosen.output;
  producer.addGoods(outSym, scale);

  // Value accounting
  const inputValue = scale * colSum * UNIT_PRICE;
  const outputValue = scale * UNIT_PRICE;
  const laborValue = outputValue - inputValue; // = scale * (1-colSum) * UNIT_PRICE

  // ── Labor value split ──
  const fullLaborValue = laborValue;
  let tr = 0, surplus = 0, laborer = null;
  if (laborMode === 'commodity' && fullLaborValue > 0) {
    tr = Math.max(0.01, fullLaborValue * trRatio);
    surplus = fullLaborValue - tr;
    if (producer.money < tr) {
      // Undo: restore inputs, remove output
      for (const [sym, qty] of Object.entries(inputQtys)){
        producer.addGoods(sym, qty);
      }
      producer.removeGoods(outSym, scale);
      return false;
    }
    const laborers = proprietors.filter(p => p !== producer && !p.dead);
    if (laborers.length > 0) {
      laborer = laborers[Math.floor(Math.random() * laborers.length)];
      producer.money -= tr;
      laborer.money += tr;
    }
    surplusLabor += surplus;
    if (laborer) {
      animations.push({type:'exchange_arrow', progress:0,
        from:{x:producer.x,y:producer.y}, to:{x:laborer.x,y:laborer.y},
        label:`t\u1D63=${tr.toFixed(1)}`, color:'#3fb950'});
    }
  }

  producer.role='producer'; producer.roleTimer=8;
  productionCount++;

  // Animations
  const outType = typeBySymbol(outSym);
  animations.push({type:'production', x:producer.x, y:producer.y, progress:0});
  const labelExtra = laborMode==='commodity' && laborer
    ? `+${fullLaborValue.toFixed(1)} (t\u1D63=${tr.toFixed(1)}, s=${surplus.toFixed(1)})`
    : `+${fullLaborValue.toFixed(1)}`;
  animations.push({type:'produce_label', x:producer.x, y:producer.y, progress:0,
    label:`\u2191 ${scale.toFixed(2)} ${outSym} ${labelExtra}`, color:outType?.color||'#3fb950'});

  const inStr  = Object.entries(inputQtys).map(([s,q])=>`${q.toFixed(2)}${s}`).join('+');
  const laborStr = laborMode==='commodity' && laborer
    ? `+${fullLaborValue.toFixed(1)} labor (${laborer.label} t\u1D63=${tr.toFixed(1)}, s=${surplus.toFixed(1)})`
    : `+${fullLaborValue.toFixed(1)} labor`;
  const rLabel = recipeLabel(chosen);
  logEntry('production',`${producer.label}: ${inStr} \u2192 ${scale.toFixed(2)} ${outSym}  ${laborStr}  [${rLabel}]`);

  // Recipe toast
  const toast = document.getElementById('recipeToast');
  toast.textContent = `${producer.label}  ${rLabel}   ${inStr}\u2192${scale.toFixed(2)}${outSym} (${laborStr})`;
  toast.classList.add('visible');
  recipeTimer = 20;
  return true;
}

function attemptCapital(cap){
  if (cap.dead) return;
  if (cap.money<5) return;

  // M→C: buy fraction of a good from seller
  const sellers = proprietors.filter(p=>p!==cap && !p.dead && p.totalGoods()>DEATH_THRESHOLD);
  if (!sellers.length) return;
  const seller = sellers[Math.floor(Math.random()*sellers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  const m1 = qty * UNIT_PRICE;
  if (cap.money < m1 || qty < DEATH_THRESHOLD) return;

  // C→M': find a buyer willing to pay markup (layer-divergent operation §11.3)
  const markup = Math.max(0.5, m1 * 0.2);
  const m2 = m1 + markup;
  const buyers = proprietors.filter(p=>p!==cap && p!==seller && !p.dead && p.money>=m2);
  if (!buyers.length) return; // no buyer at markup → no capital circuit

  const buyer = buyers[Math.floor(Math.random()*buyers.length)];

  // Execute M→C→M': commodity passes through, money redistributed
  cap.money -= m1;            // capitalist pays seller
  seller.money += m1;
  seller.removeGoods(sym, qty);
  buyer.money -= m2;           // buyer pays capitalist at markup
  cap.money += m2;
  buyer.addGoods(sym, qty);   // commodity reaches final buyer (stays in G!)

  const surp = m2 - m1;    // δ = M' − M
  cap.capitalSurplus += surp;
  surplusAccumulated += surp;

  cap.role='capitalist'; cap.roleTimer=12;
  seller.role='seller'; seller.roleTimer=6;
  buyer.role='buyer'; buyer.roleTimer=6;
  exchangeCount += 2; // two exchanges in the circuit

  // Animations: seller → cap → buyer
  animations.push({type:'capital', from:{x:seller.x,y:seller.y}, to:{x:cap.x,y:cap.y}, progress:0});
  animations.push({type:'capital', from:{x:cap.x,y:cap.y}, to:{x:buyer.x,y:buyer.y}, progress:0});
  logEntry('capital',`${cap.label}: M(${m1.toFixed(1)})\u2192C(${qty.toFixed(2)} ${sym})\u2192M'(${m2.toFixed(1)}), \u03B4=${surp.toFixed(1)}  [${seller.label}\u2192${cap.label}\u2192${buyer.label}]`);
}

// ── Animations ──
function addExchangeAnim(buyer, seller, sym, qty, price){
  const ctype = typeBySymbol(sym);
  // Money arrow: buyer → seller
  animations.push({type:'exchange_arrow', from:{x:buyer.x,y:buyer.y}, to:{x:seller.x,y:seller.y}, progress:0,
    color:'#58a6ff', label:`m=${price.toFixed(1)}`});
  // Commodity arrow: seller → buyer
  animations.push({type:'exchange_arrow', from:{x:seller.x,y:seller.y}, to:{x:buyer.x,y:buyer.y}, progress:0,
    color:ctype?.color||'#f0883e', label:`${qty.toFixed(2)} ${sym}`});
}

// ── Render ──
function resize(){
  const cw = canvas.parentElement;
  canvas.width  = cw.clientWidth * DPR;
  canvas.height = cw.clientHeight * DPR;
  canvas.style.width  = cw.clientWidth + 'px';
  canvas.style.height = cw.clientHeight + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);

  const cc = chartCanvas.parentElement;
  chartCanvas.width  = cc.clientWidth * DPR;
  chartCanvas.height = cc.clientHeight * DPR;
  chartCanvas.style.width  = cc.clientWidth + 'px';
  chartCanvas.style.height = cc.clientHeight + 'px';
  chartCtx.setTransform(DPR,0,0,DPR,0,0);

  if (proprietors.length){
    const cx = canvas.width/(2*DPR);
    const cy = canvas.height/(2*DPR);
    const r  = Math.min(cx,cy)*0.73;
    const n  = proprietors.length;
    for (let i=0;i<n;i++){
      const a = 2*Math.PI*i/n - Math.PI/2;
      proprietors[i].x = cx+r*Math.cos(a);
      proprietors[i].y = cy+r*Math.sin(a);
    }
  }
}

function draw(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  ctx.clearRect(0,0,W,H);
  const cx = W/2, cy = H/2;
  const radius = Math.min(cx,cy)*0.73;

  // Circulation ring
  ctx.beginPath(); ctx.arc(cx,cy,radius,0,2*Math.PI);
  ctx.strokeStyle='#30363d'; ctx.lineWidth=2; ctx.stroke();

  // Center label
  ctx.textAlign='center'; ctx.textBaseline='middle';
  if (mode==='cc'){
    ctx.font='26px Georgia'; ctx.fillStyle='#c6cdd5';
    ctx.fillText('CC \u2014 Stabilized Commodity Region', cx, cy-20);
    ctx.font='italic 33px Georgia'; ctx.fillStyle='#8b949eaa';
    ctx.fillText('C \u2192 M \u2192 C\u2032', cx, cy+20);
  } else {
    ctx.font='26px Georgia'; ctx.fillStyle='#bfa0d4';
    ctx.fillText('Capital Circuit', cx, cy-20);
    ctx.font='italic 33px Georgia'; ctx.fillStyle='#bfa0d4aa';
    ctx.fillText('M \u2192 C \u2192 \u2026 \u2192 M\u2032', cx, cy+20);
  }

  // Animations
  for (let i=animations.length-1;i>=0;i--){
    const a=animations[i];
    // Exchange arrows: fade time correlates with sim speed, minimum 1 second
    const simSpd = +document.getElementById('speed').value;
    const fadeMs = Math.max(1000, 3000/simSpd);
    const exchFade = 1/(fadeMs/1000*60);
    const spd = (a.type==='produce_label') ? 0.015
              : (a.type==='exchange_arrow') ? exchFade
              : 0.025;
    a.progress += spd;
    if (a.progress>=1){ animations.splice(i,1); continue; }
    const t=a.progress;
    const fade = Math.floor((1-t)*255).toString(16).padStart(2,'0');

    if (a.type==='exchange_arrow'){
      // Draw a transparent arrow with white border from source → target
      const nodeR = Math.min(52, radius*0.34);
      const dx=a.to.x-a.from.x, dy=a.to.y-a.from.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if (dist<1) continue;
      const ux=dx/dist, uy=dy/dist; // unit vector
      // Start/end inset from node edges
      const sx=a.from.x+ux*(nodeR+14), sy=a.from.y+uy*(nodeR+14);
      const ex=a.to.x-ux*(nodeR+14),   ey=a.to.y-uy*(nodeR+14);
      // Arrowhead
      const headLen=14, headW=7;
      const ax1=ex-ux*headLen+uy*headW, ay1=ey-uy*headLen-ux*headW;
      const ax2=ex-ux*headLen-uy*headW, ay2=ey-uy*headLen+ux*headW;

      const alpha = (1-t)*0.7; // fades to transparent

      // Shaft: white-bordered transparent line
      ctx.save();
      ctx.globalAlpha = alpha;
      // Outer stroke (white border)
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex-ux*headLen*0.5, ey-uy*headLen*0.5);
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=4; ctx.stroke();
      // Inner stroke (colored, thinner)
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex-ux*headLen*0.5, ey-uy*headLen*0.5);
      ctx.strokeStyle=a.color; ctx.lineWidth=2; ctx.stroke();
      // Arrowhead
      ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ax1,ay1); ctx.lineTo(ax2,ay2); ctx.closePath();
      ctx.fillStyle='#ffffff'; ctx.fill();
      ctx.fillStyle=a.color; ctx.globalAlpha=alpha*0.6; ctx.fill();
      ctx.restore();

      // Label at midpoint
      if (a.label){
        const mx=(sx+ex)/2 - uy*16, my=(sy+ey)/2 + ux*16; // offset perpendicular
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font='bold 18px "SF Mono",Consolas,monospace';
        ctx.fillStyle='#ffffff';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(a.label, mx, my);
        ctx.restore();
      }
    } else if (a.type==='production'){
      const s=35*(1-t);
      ctx.beginPath(); ctx.arc(a.x,a.y,s,0,2*Math.PI);
      ctx.strokeStyle='#3fb950'+fade; ctx.lineWidth=2.5; ctx.stroke();
      // Inner glow
      ctx.beginPath(); ctx.arc(a.x,a.y,s*0.5,0,2*Math.PI);
      ctx.strokeStyle='#3fb95044'; ctx.lineWidth=1; ctx.stroke();
    } else if (a.type==='consume'){
      const s=20*t;
      ctx.beginPath(); ctx.arc(a.x,a.y+s*2,4*(1-t),0,2*Math.PI);
      ctx.fillStyle=(a.color||'#da3633')+fade; ctx.fill();
      // Downward arrow
      ctx.font='21px Georgia'; ctx.fillStyle='#e8585a'+fade;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('\u2193', a.x, a.y+s*3);
    } else if (a.type==='capital'){
      const dx=a.to.x-a.from.x, dy=a.to.y-a.from.y;
      const bx=(a.from.x+a.to.x)/2 + (-dy*0.2);
      const by=(a.from.y+a.to.y)/2 + (dx*0.2);
      const px=(1-t)*(1-t)*a.from.x + 2*(1-t)*t*bx + t*t*a.to.x;
      const py=(1-t)*(1-t)*a.from.y + 2*(1-t)*t*by + t*t*a.to.y;
      ctx.beginPath(); ctx.arc(px,py,6,0,2*Math.PI);
      ctx.fillStyle='#d2a8ff'+fade; ctx.fill();
      for (let j=1;j<4;j++){
        const tt=Math.max(0,t-j*0.04);
        const tx=(1-tt)*(1-tt)*a.from.x+2*(1-tt)*tt*bx+tt*tt*a.to.x;
        const ty=(1-tt)*(1-tt)*a.from.y+2*(1-tt)*tt*by+tt*tt*a.to.y;
        ctx.beginPath(); ctx.arc(tx,ty,3,0,2*Math.PI);
        ctx.fillStyle='#d2a8ff44'; ctx.fill();
      }
    } else if (a.type==='produce_label'){
      // Floating upward label showing what was produced
      const rise = 70 * t;
      const nodeR = Math.min(52, radius*0.34);
      const startY = a.y - nodeR - 16;
      ctx.font='bold 24px "SF Mono",Consolas,monospace';
      ctx.fillStyle = a.color + fade;
      ctx.textAlign='center'; ctx.textBaseline='bottom';
      ctx.fillText(a.label, a.x, startY - rise);
    }
  }

  // Proprietors
  for (const p of proprietors){
    const R = Math.min(52, radius*0.34);

    let bg='#161b22', border='#30363d';
    if (p.dead) { bg='#0d0d0d'; border='#4a2020'; }
    else if (p.role==='buyer')     {border='#58a6ff'; bg='#0d2240';}
    else if (p.role==='seller')    {border='#f0883e'; bg='#3d1f00';}
    else if (p.role==='producer')  {border='#3fb950'; bg='#0a3d1c';}
    else if (p.role==='capitalist'){border='#d2a8ff'; bg='#2d1a4e';}
    if (!p.dead && p.isCapitalist&&mode==='capital'){border='#d2a8ff'; bg='#2d1a4e';}

    ctx.beginPath(); ctx.arc(p.x,p.y,R,0,2*Math.PI);
    ctx.fillStyle=bg; ctx.fill();
    ctx.strokeStyle=border; ctx.lineWidth=p.dead?1.5:2.5; ctx.stroke();

    if (p.dead) {
      // Skull emoji + label
      ctx.font=`${Math.max(28,R*0.7)}px sans-serif`;
      ctx.fillStyle='#ffffff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('\uD83D\uDC80', p.x, p.y-R*0.1);
      ctx.font=`bold ${Math.max(14,R*0.36)}px Georgia`;
      ctx.fillStyle='#6e4444';
      ctx.fillText(p.label, p.x, p.y+R*0.5);
    } else {
      // Name
      ctx.font=`bold ${Math.max(22,R*0.58)}px Georgia`;
      ctx.fillStyle='#f8fafc'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.label, p.x, p.y-R*0.22);

      // Money (smaller, below name)
      ctx.font=`${Math.max(14,R*0.38)}px "SF Mono",Consolas,monospace`;
      ctx.fillStyle='#9dd3ff';
      ctx.fillText(`m=${p.money.toFixed(1)}`, p.x, p.y+R*0.22);

      // Inventory arc segments (colored arcs proportional to share of each type)
      const entries = Object.entries(p.inventory).filter(([_, q]) => q > DEATH_THRESHOLD);
      const total = entries.reduce((s, [_, q]) => s + q, 0);
      if (total > 0) {
        let startAngle = -Math.PI / 2;
        for (const [sym, qty] of entries) {
          const sweep = (qty / total) * 2 * Math.PI;
          if (sweep < 0.02) { startAngle += sweep; continue; }
          ctx.beginPath();
          ctx.arc(p.x, p.y, R + 8, startAngle, startAngle + sweep);
          const ctype = typeBySymbol(sym);
          ctx.strokeStyle = ctype?.color || '#888';
          ctx.lineWidth = 6;
          ctx.stroke();
          startAngle += sweep;
        }

        // Total goods below node
        ctx.font=`${Math.max(20,R*0.42)}px Georgia`;
        ctx.fillStyle='#f5a76ecc'; ctx.textBaseline='top';
        ctx.textAlign='center';
        ctx.fillText(total.toFixed(1), p.x, p.y+R+13);
      }

      // Capital δ
      if (p.isCapitalist && p.capitalSurplus>0){
        ctx.font=`bold ${Math.max(22,R*0.48)}px "SF Mono",Consolas,monospace`;
        ctx.fillStyle='#e0bfff'; ctx.textBaseline='bottom';
        ctx.textAlign='center';
        ctx.fillText(`\u03B4=${p.capitalSurplus.toFixed(1)}`, p.x, p.y-R-8);
      }
    }
  }

  // ── Node anatomy legend (top-left) ──
  drawNodeLegend(ctx);

  // Depletion warning
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (G<DEATH_THRESHOLD){
    ctx.font='bold 36px Georgia'; ctx.fillStyle='#ff6b6b';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('\u26A0  G \u2248 0 \u2014 Commodity depletion', cx, cy+56);
    ctx.font='24px Georgia'; ctx.fillStyle='#f5a76e';
    ctx.fillText('Circulation halted. Enable production to stabilize. \u00A79.10', cx, cy+92);
  }

  drawChart();
}

function drawNodeLegend(ctx){
  const lx = 18, ly = 16; // top-left origin
  const R = 44; // legend node radius (2x)
  const nodeCx = lx + R + 16, nodeCy = ly + R + 48; // extra top margin below title

  // Background panel
  const pw = 420, ph = 280;
  ctx.fillStyle = '#0d1117dd';
  ctx.strokeStyle = '#30363d';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(lx, ly, pw, ph, 10);
  ctx.fill(); ctx.stroke();

  // Title
  ctx.font = '16px Georgia';
  ctx.fillStyle = '#b1bac4';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('NODE ANATOMY', lx + 14, ly + 10);

  // Draw example node
  ctx.beginPath(); ctx.arc(nodeCx, nodeCy, R, 0, 2*Math.PI);
  ctx.fillStyle = '#161b22'; ctx.fill();
  ctx.strokeStyle = '#30363d'; ctx.lineWidth = 2.5; ctx.stroke();

  // Name in node
  ctx.font = 'bold 24px Georgia';
  ctx.fillStyle = '#f8fafc'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('O\u2081', nodeCx, nodeCy - 10);

  // Money in node
  ctx.font = '20px "SF Mono",Consolas,monospace';
  ctx.fillStyle = '#9dd3ff';
  ctx.fillText('m=13.0', nodeCx, nodeCy + 16);

  // Inventory arc segments around node
  const legendColors = ['#f0883e','#e06c75','#9ea5b0','#bc8cff','#a67c52'];
  let legendAngle = -Math.PI/2;
  const segAngle = 2*Math.PI / legendColors.length;
  for (let i = 0; i < legendColors.length; i++){
    ctx.beginPath();
    ctx.arc(nodeCx, nodeCy, R + 10, legendAngle, legendAngle + segAngle - 0.08);
    ctx.strokeStyle = legendColors[i];
    ctx.lineWidth = 6;
    ctx.stroke();
    legendAngle += segAngle;
  }

  // Goods total below
  ctx.font = '18px Georgia'; ctx.fillStyle = '#f5a76ecc';
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  ctx.fillText('3.2', nodeCx, nodeCy + R + 14);

  // Callout lines and labels
  const labelX = lx + 195;
  const callouts = [
    { label: 'proprietor name',  sx: nodeCx + 10, sy: nodeCy - 10, ex: labelX, ey: nodeCy - 36, lineColor: '#e0e6ef', textColor: '#f0f6fc' },
    { label: 'money holdings',   sx: nodeCx + 14, sy: nodeCy + 16, ex: labelX, ey: nodeCy + 4,  lineColor: '#7bbfef', textColor: '#9dd3ff' },
    { label: 'inventory arcs (owned goods)', sx: nodeCx + R + 10, sy: nodeCy - 6, ex: labelX, ey: nodeCy + 42, lineColor: '#d09060', textColor: '#f5a76e' },
    { label: 'goods total',  sx: nodeCx, sy: nodeCy + R + 20, ex: labelX, ey: nodeCy + 78, lineColor: '#c08050', textColor: '#f5a76e' },
  ];

  ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  for (const c of callouts){
    // Leader line — bright, visible stroke
    ctx.beginPath();
    ctx.moveTo(c.sx, c.sy);
    ctx.lineTo(c.ex - 4, c.ey);
    ctx.strokeStyle = c.lineColor; ctx.lineWidth = 1.5; ctx.stroke();
    // Dot at source
    ctx.beginPath(); ctx.arc(c.sx, c.sy, 3, 0, 2*Math.PI);
    ctx.fillStyle = c.lineColor; ctx.fill();
    // Dot at label end
    ctx.beginPath(); ctx.arc(c.ex - 4, c.ey, 2, 0, 2*Math.PI);
    ctx.fillStyle = c.lineColor; ctx.fill();
    // Label
    ctx.font = '17px Georgia';
    ctx.fillStyle = c.textColor;
    ctx.fillText(c.label, c.ex, c.ey);
  }
}

function drawChart(){
  const W = chartCanvas.width/DPR, H = chartCanvas.height/DPR;
  chartCtx.clearRect(0,0,W,H);
  if (gHistory.length<2) return;

  const pad = {l:50, r:12, t:2, b:16};
  const gap = 1;
  const cw = W - pad.l - pad.r;

  const series = [
    { data: gHistory,           color: '#f0883e', label: '|G| goods' },
    { data: vHistory,           color: '#79c0ff', label: 'V value' },
    { data: mHistory,           color: '#588bdd', label: 'M money' },
    { data: exchPerTickHistory, color: '#58a6ff', label: 'Exchanges/t' },
    { data: prodPerTickHistory, color: '#3fb950', label: 'Production/t' },
    { data: consPerTickHistory, color: '#da3633', label: 'Consumption/t' },
  ];
  const numRows = series.length;
  const totalH = H - pad.t - pad.b;
  const rowH = (totalH - gap * (numRows - 1)) / numRows;

  for (let s = 0; s < numRows; s++){
    const {data, color, label} = series[s];
    if (data.length < 2) continue;
    const top = pad.t + s * (rowH + gap);

    // Alternating subtle background
    if (s % 2 === 1){
      chartCtx.fillStyle = '#161b2233';
      chartCtx.fillRect(pad.l, top, cw, rowH);
    }

    // Separator line at bottom of each row
    chartCtx.strokeStyle = '#21262d'; chartCtx.lineWidth = 1;
    chartCtx.beginPath();
    chartCtx.moveTo(pad.l, top + rowH);
    chartCtx.lineTo(pad.l + cw, top + rowH);
    chartCtx.stroke();

    // Left axis
    chartCtx.beginPath();
    chartCtx.moveTo(pad.l, top);
    chartCtx.lineTo(pad.l, top + rowH);
    chartCtx.stroke();

    // Data line — 0-based y-axis (no min-max rescaling artifacts)
    const max = Math.max(...data, 0.1);
    const margin = rowH * 0.12;
    const plotH = rowH - 2 * margin;
    const pts = data.slice(-Math.floor(cw));
    const step = cw / Math.max(pts.length - 1, 1);

    chartCtx.beginPath();
    for (let i = 0; i < pts.length; i++){
      const x = pad.l + i * step;
      const y = top + margin + plotH - (pts[i] / max) * plotH;
      i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
    }
    chartCtx.strokeStyle = color; chartCtx.lineWidth = 1.8; chartCtx.stroke();

    // Current value — left of axis
    const last = pts[pts.length - 1];
    const lastY = top + margin + plotH - (last / max) * plotH;
    chartCtx.font = '12px "SF Mono",Consolas,monospace';
    chartCtx.fillStyle = color;
    chartCtx.textAlign = 'right'; chartCtx.textBaseline = 'middle';
    const clampedY = Math.max(top + 7, Math.min(top + rowH - 5, lastY));
    // Format: integers for counts, 1 decimal for quantities
    const valStr = (s >= 3) ? String(Math.round(last)) : last.toFixed(1);
    chartCtx.fillText(valStr, pad.l - 3, clampedY);

    // Label — top-left inside chart area
    chartCtx.font = '12px Georgia';
    chartCtx.fillStyle = color;
    chartCtx.textAlign = 'left'; chartCtx.textBaseline = 'top';
    chartCtx.fillText(label, pad.l + 4, top + 1);
  }

  // Shared time axis at bottom
  chartCtx.font = '12px "SF Mono",Consolas,monospace'; chartCtx.fillStyle = '#8b949e';
  chartCtx.textAlign = 'center'; chartCtx.textBaseline = 'top';
  const btm = pad.t + numRows * rowH + (numRows - 1) * gap;
  chartCtx.fillText(`t=${tick}`, pad.l + cw, btm + 1);
  chartCtx.fillText('0', pad.l, btm + 1);
}

// ── Stats ──
function updateStats(){
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  const M = proprietors.reduce((s,p)=>s+p.money,0);
  const V = proprietors.reduce((s,p)=>s+p.totalValue(),0);
  document.getElementById('stat-tick').textContent = tick;
  document.getElementById('stat-G').textContent = G.toFixed(1);
  document.getElementById('stat-Mcirc').textContent = M.toFixed(1);
  document.getElementById('stat-Mtotal').textContent = V.toFixed(1);
  document.getElementById('stat-exchanges').textContent = exchangeCount;
  document.getElementById('stat-productions').textContent = productionCount;
  document.getElementById('stat-surplus').textContent = surplusAccumulated.toFixed(1);
  document.getElementById('stat-surplus-labor').textContent = surplusLabor.toFixed(1);
}

// ── Editable Leontief technology matrix ──
function renderEditableMatrix(){
  const el = document.getElementById('techMatrix');
  if(!el) return;
  const canRemove = TYPES.length > 1;
  let html = '';
  for (let j=0; j<LEONTIEF_RECIPES.length; j++){
    const r = LEONTIEF_RECIPES[j];
    const outT = TYPES.find(t=>t.sym===r.output);
    if(!outT) continue;
    const xw = PROD_WEIGHTS[j] !== undefined ? (PROD_WEIGHTS[j]*100).toFixed(0) : '?';
    const colSum = r.coeffs.reduce((s,c)=>s+c, 0);
    html += `<div class="tech-edit-row">`;
    html += `<span class="tech-edit-sym" style="color:${outT.color}">${outT.sym}</span>`;
    html += `<span class="tech-edit-arrow">\u2190</span>`;
    for (let k=0; k<r.inputs.length; k++){
      if(k>0) html += `<span class="tech-edit-plus">+</span>`;
      html += `<input type="number" min="0.05" max="0.95" step="0.05" value="${r.coeffs[k]}" onchange="onCoeffChange(${j},${k},this.value)" title="Input coefficient">`;
      html += `<select onchange="onInputChange(${j},${k},this.value)" title="Input commodity">`;
      for (const t of TYPES){
        html += `<option value="${t.sym}" ${t.sym===r.inputs[k]?'selected':''}>${t.sym}</option>`;
      }
      html += `</select>`;
    }
    html += `<span class="tech-count" title="equilibrium weight">x*${xw}%</span>`;
    html += `<button class="btn-remove" ${canRemove?'':'disabled'} onclick="removeCommodity(${j})" title="Remove commodity">\u2715</button>`;
    html += `</div>`;
  }
  // Column sum info
  if(LEONTIEF_RECIPES.length>0){
    const avgCS = LEONTIEF_RECIPES.reduce((s,r)=>s+r.coeffs.reduce((a,b)=>a+b,0),0)/LEONTIEF_RECIPES.length;
    const csClass = avgCS>=1 ? 'tech-col-sum-warn' : '';
    html += `<div class="tech-row" style="border-top:1px solid #30363d;margin-top:4px;padding-top:4px;">
      <span class="${csClass}" style="font-size:11px;">avg col \u03A3 = ${avgCS.toFixed(2)} \u2192 ${(1-avgCS).toFixed(2)} value-added</span>
    </div>`;
  }
  // Add button
  const canAdd = COMMODITY_POOL.some(c=>!TYPES.find(t=>t.sym===c.sym));
  html += `<button class="btn-add-commodity" ${canAdd?'':'disabled'} onclick="addCommodity()">+ Add Commodity</button>`;
  el.innerHTML = html;
}

function onCoeffChange(recipeIdx, inputIdx, value){
  const val = Math.max(0.05, Math.min(0.95, parseFloat(value)||0.4));
  const r = LEONTIEF_RECIPES[recipeIdx];
  const otherCoeff = r.coeffs[1-inputIdx];
  if(val+otherCoeff>=1){
    r.coeffs[inputIdx] = Math.round(Math.max(0.05, 0.99-otherCoeff)*100)/100;
  } else {
    r.coeffs[inputIdx] = Math.round(val*100)/100;
  }
  rebuildLeontief();
  resetSim();
}

function onInputChange(recipeIdx, inputIdx, sym){
  LEONTIEF_RECIPES[recipeIdx].inputs[inputIdx] = sym;
  rebuildLeontief();
  resetSim();
}

function addCommodity(){
  const available = COMMODITY_POOL.filter(c=>!TYPES.find(t=>t.sym===c.sym));
  if(!available.length) return;
  const newT = available[0];
  TYPES.push({name:newT.name, color:newT.color, sym:newT.sym});
  // Pick 2 random existing commodities as inputs (from the ones before this new one)
  const existing = TYPES.filter(t=>t.sym!==newT.sym);
  const inp1 = existing[Math.floor(Math.random()*existing.length)].sym;
  const inp2 = existing[Math.floor(Math.random()*existing.length)].sym;
  LEONTIEF_RECIPES.push({output:newT.sym, inputs:[inp1,inp2], coeffs:[0.4,0.4]});
  rebuildLeontief();
  resetSim();
}

function removeCommodity(idx){
  if(TYPES.length<=1) return;
  const removedSym = LEONTIEF_RECIPES[idx].output;
  TYPES.splice(idx,1);
  LEONTIEF_RECIPES.splice(idx,1);
  // Update any recipe that references the removed commodity as input
  for(const r of LEONTIEF_RECIPES){
    for(let k=0; k<r.inputs.length; k++){
      if(r.inputs[k]===removedSym){
        r.inputs[k] = TYPES[Math.floor(Math.random()*TYPES.length)].sym;
      }
    }
  }
  rebuildLeontief();
  resetSim();
}

function openLeontiefEditor(){
  document.getElementById('leontiefModal').classList.remove('hidden');
  renderEditableMatrix();
}
function closeLeontiefEditor(){
  document.getElementById('leontiefModal').classList.add('hidden');
}
function updateLeontiefSummary(){
  const el = document.getElementById('leontief-summary');
  if(!el) return;
  const avgCS = LEONTIEF_RECIPES.length>0
    ? LEONTIEF_RECIPES.reduce((s,r)=>s+r.coeffs.reduce((a,b)=>a+b,0),0)/LEONTIEF_RECIPES.length
    : 0;
  el.textContent = `${TYPES.length} commodities, avg col \u03A3 = ${avgCS.toFixed(2)}`;
}

function setCoupling(on){
  coupleExchangeConsumption = on;
  document.getElementById('btn-couple-on').className = on?'active':'';
  document.getElementById('btn-couple-off').className = on?'':'active';
  document.getElementById('coupling-desc').textContent = on
    ? 'Each exchange triggers consumption: buying drives using.'
    : 'Consumption and exchange are independent processes.';
}

// ── Log ──
function logEntry(type, msg){
  const log = document.getElementById('log');
  const e = document.createElement('div');
  e.className=`log-entry ${type}`;
  e.innerHTML=`<span class="time">t=${tick}</span>${msg}`;
  log.prepend(e);
  while (log.children.length>150) log.removeChild(log.lastChild);
}
function toggleLog(){
  const o = document.getElementById('logOverlay');
  o.classList.toggle('collapsed');
  document.getElementById('logToggle').textContent = o.classList.contains('collapsed') ? '\u25B6' : '\u25BC';
}

// ── Controls ──
function setMode(m){
  mode=m;
  document.getElementById('btn-mode-cc').className = m==='cc'?'active':'';
  document.getElementById('btn-mode-capital').className = m==='capital'?'active':'';
  const badge = document.getElementById('modeBadge');
  if (m==='cc'){ badge.className='mode-badge cc'; badge.textContent='CC \u2014 Simple Circulation'; }
  else { badge.className='mode-badge capital'; badge.textContent='Capital \u2014 M\u2192C\u2192M\u2032'; }
  document.getElementById('mode-desc').textContent = m==='cc'
    ? 'Stabilized commodity region: circulation + value-conserving production. §9.14'
    : 'Capital circuit: M \u2192 C \u2192 ... \u2192 M\u2032 with surplus extraction. §11.1';
  if (m==='capital') setProd('conservative');
  // Clamp t_r slider bounds by mode
  if (laborMode==='commodity') updateTrSlider();
  resetSim();
}

function setProd(p){
  prodMode=p;
  document.getElementById('btn-prod-off').className = p==='off'?'active':'';
  document.getElementById('btn-prod-conservative').className = p==='conservative'?'active':'';
  const descs = {
    off: 'No production. Circulation depletes G \u2192 0. §9.10.4',
    conservative: 'Leontief stabilizer: feedback controller drives |G| \u2192 target. Recipes from A, weighted by x*=(I\u2212A)\u207B\u00B9d. U(out)=U(in)/0.8 — labor adds 0.2 value. §9.12\u20139.14',
  };
  document.getElementById('prod-desc').textContent = descs[p] || '';
}

function toggleSection(id){
  document.getElementById(id).classList.toggle('section-collapsed');
}

function setLabor(m){
  laborMode = m;
  document.getElementById('btn-labor-implicit').className = m==='implicit'?'active':'';
  document.getElementById('btn-labor-commodity').className = m==='commodity'?'active':'';
  document.getElementById('labor-slider-group').style.display = m==='commodity'?'flex':'none';
  document.getElementById('labor-desc').textContent = m==='implicit'
    ? 'Each producer adds their own labor. No money exchanged for labor.'
    : 'Labor is a commodity: producers pay t\u1D63 to hire a laborer. Surplus s = value-added \u2212 t\u1D63 retained by producer.';
  updateTrSlider();
}

function updateTrSlider(){
  const slider = document.getElementById('trSlider');
  // Clamp bounds by mode
  const minVal = mode==='capital' ? 10 : 50;
  slider.min = minVal;
  if (+slider.value < minVal) slider.value = minVal;
  trRatio = +slider.value / 100;
  document.getElementById('tr-pct').textContent = slider.value;
  // Update description
  const pct = +slider.value;
  const desc = document.getElementById('tr-desc');
  if (pct >= 100) desc.textContent = 'Simple reproduction: t\u1D63 = value-added, no surplus (s=0).';
  else desc.textContent = `t\u1D63 = ${pct}% of value-added. Surplus s = ${100-pct}% retained by producer.`;
}

function togglePlay(){
  playing=!playing;
  document.getElementById('btn-play').innerHTML = playing ? '\u23F8 Pause' : '\u25B6 Play';
  document.getElementById('btn-play').className = playing ? 'warn' : 'primary';
}
function stepOnce(){
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (G<DEATH_THRESHOLD){ logEntry('system','\u26A0 G\u22480 \u2014 cannot step, circulation halted.'); return; }
  step();
}
function resetSim(){
  playing=false;
  document.getElementById('btn-play').innerHTML='\u25B6 Play';
  document.getElementById('btn-play').className='primary';
  document.getElementById('log').innerHTML='';
  resize(); init();
}

// ── Loop ──
let lastStep=0;
function loop(ts){
  requestAnimationFrame(loop);
  const spd = +document.getElementById('speed').value;
  if (playing && ts-lastStep > 1000/spd){ step(); lastStep=ts; }
  draw();
}

window.addEventListener('resize', ()=>{ resize(); });
rebuildLeontief();
resize(); init();
requestAnimationFrame(loop);
</script>
</body>
</html>
