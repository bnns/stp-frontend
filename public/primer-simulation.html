<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Value, Capital &amp; Reproduction — Dynamic Model</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Georgia', serif;
    background: #0d1117;
    color: #e6edf3;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* ── Header ── */
  header {
    padding: 12px 24px;
    border-bottom: 1px solid #21262d;
    display: flex;
    align-items: center;
    gap: 16px;
    flex-shrink: 0;
  }
  header h1 { font-size: 24px; color: #f0f6fc; font-weight: 600; }
  header .subtitle { font-size: 15px; color: #b1bac4; }
  .mode-badge {
    margin-left: auto;
    padding: 5px 16px;
    border-radius: 14px;
    font-size: 15px;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  .mode-badge.cc  { background: #0d419d; color: #79c0ff; }
  .mode-badge.simple { background: #5b0d5b; color: #d2a8ff; }
  .mode-badge.expanded { background: #5b3000; color: #ffa060; }

  /* ── Main grid ── */
  .main-grid {
    flex: 1;
    display: grid;
    grid-template-columns: 280px 1fr;
    grid-template-rows: 1fr;
    overflow: hidden;
  }

  /* ── Left sidebar ── */
  .sidebar {
    padding: 16px;
    border-right: 1px solid #21262d;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 14px;
    font-size: 15px;
  }
  .group { display: flex; flex-direction: column; gap: 5px; }
  .group-label {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #b1bac4;
    font-weight: 600;
  }
  .group .desc { font-size: 14px; color: #8b949e; line-height: 1.4; }
  .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
  button {
    padding: 8px 16px;
    border: 1px solid #30363d;
    border-radius: 6px;
    background: #21262d;
    color: #e6edf3;
    font-size: 15px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  button:hover { background: #30363d; border-color: #484f58; }
  button.primary { background: #238636; border-color: #2ea043; color: #fff; }
  button.primary:hover { background: #2ea043; }
  button.warn { background: #8b1538; border-color: #da3633; color:#fff; }
  button.warn:hover { background: #b62324; }
  button.active { background: #1f6feb; border-color: #388bfd; color: #fff; }
  input[type="range"] { width: 100%; accent-color: #388bfd; }

  .stat-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 3px 0; font-size: 15px;
  }
  .stat-value {
    font-variant-numeric: tabular-nums;
    color: #f0f6fc; font-weight: 700;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 15px;
  }
  .divider { border-top: 1px solid #21262d; margin: 4px 0; }

  /* ── Right: canvas + chart ── */
  .canvas-col {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }

  /* Circulation canvas takes ~65% */
  .circ-wrap {
    flex: 7;
    position: relative;
    min-height: 0;
  }
  #world { display: block; width: 100%; height: 100%; }

  /* Chart strip at bottom */
  .chart-strip {
    flex: 5;
    min-height: 220px;
    border-top: 1px solid #21262d;
    position: relative;
    background: #0d1117;
  }
  #chart { display: block; width: 100%; height: 100%; }

  /* Legend bar between them */
  .legend-bar {
    display: flex;
    gap: 20px;
    padding: 6px 20px;
    border-top: 1px solid #21262d;
    font-size: 14px;
    color: #b1bac4;
    flex-shrink: 0;
    flex-wrap: wrap;
    background: #0d1117;
  }
  .legend-item { display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; transition: opacity 0.15s; }
  .legend-item.off { opacity: 0.3; }
  .legend-item.off .legend-dot { background: #6e7681 !important; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

  /* Floating log overlay */
  .log-overlay {
    position: absolute;
    top: 8px; right: 8px;
    width: 320px;
    max-height: 45%;
    background: #0d1117ee;
    border: 1px solid #21262d;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-size: 12px;
    z-index: 10;
  }
  .log-overlay.collapsed .log-entries { display: none; }
  .log-hdr {
    padding: 6px 12px;
    border-bottom: 1px solid #21262d;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #b1bac4;
    cursor: pointer;
    display: flex; justify-content: space-between; align-items: center;
    user-select: none;
  }
  .log-entries {
    overflow-y: auto;
    padding: 4px 10px;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 13px;
    line-height: 1.5;
  }
  .log-entry { padding: 2px 0; border-bottom: 1px solid #161b2288; }
  .log-entry .time { color: #6e7681; margin-right: 4px; }
  .log-entry.exchange { color: #79c0ff; }
  .log-entry.production { color: #56d364; }
  .log-entry.depletion { color: #f0883e; }
  .log-entry.capital { color: #d2a8ff; }
  .log-entry.system  { color: #b1bac4; }

  /* Technology matrix */
  .tech-matrix {
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 12px;
    line-height: 1.55;
    max-height: 200px;
    overflow-y: auto;
  }
  .tech-row {
    display: flex;
    align-items: baseline;
    gap: 4px;
    padding: 2px 0;
    border-bottom: 1px solid #161b2244;
  }
  .tech-out {
    font-weight: 700;
    min-width: 32px;
  }
  .tech-arrow { color: #6e7681; }
  .tech-coeff {
    color: #b1bac4;
  }
  .tech-coeff .sym { font-weight: 600; }
  .tech-count { color: #6e7681; font-size: 11px; margin-left: auto; }

  /* Editable technology matrix */
  .tech-edit-row {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 3px 0;
    border-bottom: 1px solid #161b2244;
    flex-wrap: wrap;
  }
  .tech-edit-row select, .tech-edit-row input[type="number"] {
    background: #161b22;
    border: 1px solid #30363d;
    color: #e6edf3;
    border-radius: 4px;
    padding: 2px 3px;
    font-family: 'SF Mono','Consolas',monospace;
    font-size: 11px;
  }
  .tech-edit-row select { width: 100px; }
  .tech-edit-row input[type="number"] { width: 88px; }
  .tech-edit-row .btn-remove {
    background: none;
    border: none;
    color: #da3633;
    cursor: pointer;
    font-size: 13px;
    padding: 0 3px;
    line-height: 1;
  }
  .tech-edit-row .btn-remove:hover { color: #ff6b6b; }
  .tech-edit-row .btn-remove:disabled { color: #30363d; cursor: default; }
  .btn-add-commodity {
    margin-top: 6px;
    padding: 4px 10px;
    font-size: 12px;
  }
  .tech-edit-sym {
    font-weight: 700;
    min-width: 24px;
    text-align: center;
  }
  .tech-edit-arrow {
    color: #6e7681;
    font-size: 11px;
  }
  .tech-edit-plus {
    color: #6e7681;
    font-size: 10px;
  }
  .tech-col-sum-warn {
    color: #da3633;
    font-weight: 700;
  }

  /* Modal */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }
  .modal-overlay.hidden { display: none; }
  .modal {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 12px;
    padding: 24px;
    max-width: 560px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }
  .modal-header h2 {
    font-size: 18px;
    color: #f0f6fc;
    font-weight: 600;
  }
  .modal-close {
    background: none;
    border: none;
    color: #8b949e;
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
  }
  .modal-close:hover { color: #f0f6fc; }

  /* Collapsible sidebar sections */
  .collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
    padding: 2px 0;
  }
  .collapsible-header:hover .collapse-arrow { color: #e6edf3; }
  .collapse-arrow {
    font-size: 11px;
    color: #6e7681;
    transition: transform 0.2s, color 0.15s;
    flex-shrink: 0;
  }
  .collapsible-body {
    display: flex;
    flex-direction: column;
    gap: 5px;
    overflow: hidden;
    transition: max-height 0.25s ease, opacity 0.2s ease;
    max-height: 600px;
    opacity: 1;
  }
  .section-collapsed .collapsible-body {
    max-height: 0;
    opacity: 0;
    pointer-events: none;
  }
  .section-collapsed .collapse-arrow {
    transform: rotate(-90deg);
  }

  /* Production recipe callout (shown on canvas) */
  /* Legend overlay */
  .legend-overlay {
    position: absolute;
    top: 8px; left: 8px;
    width: 280px;
    max-height: 70%;
    background: #0d1117ee;
    border: 1px solid #21262d;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-size: 13px;
    z-index: 10;
  }
  .legend-overlay.collapsed .legend-body { display: none; }
  .legend-body {
    overflow-y: auto;
    padding: 8px 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .legend-section-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #6e7681;
    margin-top: 6px;
    padding-bottom: 3px;
    border-bottom: 1px solid #21262d;
  }
  .legend-row {
    display: flex;
    align-items: center;
    gap: 8px;
    line-height: 1.4;
  }
  .legend-icon {
    flex-shrink: 0;
    width: 24px;
    text-align: center;
    font-size: 15px;
  }
  .legend-text {
    color: #b1bac4;
    font-size: 12px;
  }
  .legend-text b { color: #e6edf3; font-weight: 600; }

  .recipe-toast {
    position: absolute;
    transform: translateX(-50%);
    background: #0a3d1cdd;
    border: 1px solid #3fb950;
    border-radius: 8px;
    padding: 10px 18px;
    font-size: 16px;
    color: #56d364;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 5;
    text-align: center;
    font-family: 'SF Mono','Consolas',monospace;
  }
  .recipe-toast.visible { opacity: 1; }

  /* Presets */
  .preset-input-row {
    display: flex; flex-direction: column; gap: 5px;
  }
  .preset-input-row input[type="text"] {
    width: 100%;
    padding: 6px 10px;
    border: 1px solid #30363d;
    border-radius: 6px;
    background: #161b22;
    color: #e6edf3;
    font-size: 14px;
    font-family: inherit;
  }
  .preset-input-row input[type="text"]::placeholder { color: #6e7681; }
  .preset-input-row button:disabled { opacity: 0.4; cursor: default; }
  .preset-list { display: flex; flex-direction: column; gap: 3px; max-height: 180px; overflow-y: auto; }
  .preset-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.12s;
  }
  .preset-item:hover { background: #21262d; }
  .preset-item .preset-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .preset-item .preset-delete {
    background: none; border: none; color: #6e7681; cursor: pointer;
    font-size: 15px; padding: 0 4px; line-height: 1; flex-shrink: 0;
  }
  .preset-item .preset-delete:hover { color: #da3633; }

  #_m {
    font-size: 11px !important;
    color: #6e7681 !important;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    position: static !important;
    height: auto !important;
    overflow: visible !important;
    pointer-events: auto !important;
    clip: auto !important;
    margin-left: auto;
    white-space: nowrap;
    letter-spacing: 0.2px;
  }
  #_m i { font-style: italic; }
</style>
<script src="https://cdn.counter.dev/script.js" data-id="594404c5-6814-4476-a5af-d35ddc284e98" data-utcoffset="-5"></script>
</head>
<body>

<header>
  <h1>Value, Capital &amp; Reproduction</h1>
  <span class="subtitle">Dynamic model — Primer §9-22</span>
  <div class="mode-badge cc" id="modeBadge">Circulation &sect;9</div>
</header>

<div class="main-grid">
  <!-- ── Sidebar ── -->
  <div class="sidebar">
    <div class="group">
      <div class="group-label">Mode</div>
      <div class="btn-row">
        <button id="btn-mode-cc" class="active" onclick="setMode('cc')">Circulation</button>
        <button id="btn-mode-simple" onclick="setMode('simple')">Capital</button>
        <button id="btn-mode-expanded" onclick="setMode('expanded')">Reproduction</button>
      </div>
      <div class="desc" id="mode-desc">Commodity circulation with value-conserving production. &sect;9</div>
    </div>

    <div class="group">
      <div class="group-label">Simulation</div>
      <div class="btn-row">
        <button class="primary" id="btn-play" onclick="togglePlay()">&#x25B6; Play</button>
        <button onclick="stepOnce()">Step</button>
        <button class="warn" onclick="resetSim()">Reset</button>
      </div>
    </div>

    <div class="group">
      <div class="group-label">Speed</div>
      <input type="range" id="speed" min="1" max="20" value="5">
    </div>

    <div class="group">
      <div class="group-label">Proprietors &mdash; <span id="prop-count">6</span></div>
      <input type="range" id="numProprietors" min="3" max="12" value="6" oninput="document.getElementById('prop-count').textContent=this.value" onchange="resetSim()">
    </div>

    <div class="group">
      <div class="group-label">Init. goods each &mdash; <span id="comm-count">3</span></div>
      <input type="range" id="initCommodities" min="1" max="8" value="3" oninput="document.getElementById('comm-count').textContent=this.value" onchange="resetSim()">
    </div>

    <div class="divider"></div>

    <!-- 1. Statistics (expanded by default) -->
    <div class="group" id="section-stats">
      <div class="collapsible-header" onclick="toggleSection('section-stats')">
        <div class="group-label">Statistics &mdash; t = <span id="stat-tick">0</span></div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="stat-row"><span>Goods |G|</span><span class="stat-value" id="stat-G">0</span></div>
        <div class="stat-row"><span>Total money M</span><span class="stat-value" id="stat-Mcirc">0</span></div>
        <div class="stat-row"><span>Goods value V</span><span class="stat-value" id="stat-Mtotal">0</span></div>
        <div class="stat-row"><span>Exchanges</span><span class="stat-value" id="stat-exchanges">0</span></div>
        <div class="stat-row"><span>Productions</span><span class="stat-value" id="stat-productions">0</span></div>
        <div class="stat-row"><span>Arbitrage &delta;</span><span class="stat-value" id="stat-surplus">0</span></div>
        <div class="stat-row"><span>Surplus &delta;</span><span class="stat-value" id="stat-surplus-labor">0</span></div>
        <div class="stat-row"><span>Merchant profit</span><span class="stat-value" id="stat-merchant">0</span></div>
        <div class="stat-row"><span>Active loans</span><span class="stat-value" id="stat-loans">0</span></div>
        <div class="stat-row"><span>Usury interest</span><span class="stat-value" id="stat-usury">0</span></div>
      </div>
    </div>

    <div class="divider" id="divider-arbitrage"></div>

    <div class="group" id="section-arbitrage">
      <div class="group-label">Arbitrage</div>
      <div class="btn-row">
        <button id="btn-arb-on" onclick="setArbitrage(true)">On</button>
        <button id="btn-arb-off" class="active" onclick="setArbitrage(false)">Off</button>
      </div>
      <div class="desc" id="arb-desc">Any proprietor can buy low, sell high (price &ne; value). Independent of mode.</div>
    </div>

    <div class="divider" id="divider-production"></div>

    <!-- 2. Production (collapsed by default) -->
    <div class="group section-collapsed" id="section-production">
      <div class="collapsible-header" onclick="toggleSection('section-production')">
        <div class="group-label">Production (Stabilizer)</div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="btn-row">
          <button id="btn-prod-off" onclick="setProd('off')">Off</button>
          <button id="btn-prod-conservative" class="active" onclick="setProd('conservative')">On (Leontief)</button>
        </div>
        <div class="desc" id="prod-desc">Value-conserving: U(outputs) = U(inputs). The stabilizer couples production to circulation so G is replenished. §9.12&ndash;9.14</div>
      </div>
    </div>

    <div class="divider" id="divider-coupling"></div>

    <!-- 2b. Exchange-Consumption Coupling -->
    <div class="group" id="section-coupling">
      <div class="group-label">Exchange &harr; Consumption</div>
      <div class="btn-row">
        <button id="btn-couple-on" class="active" onclick="setCoupling(true)">Coupled</button>
        <button id="btn-couple-off" onclick="setCoupling(false)">Independent</button>
      </div>
      <div class="desc" id="coupling-desc">Each exchange triggers consumption: buying drives using.</div>
    </div>

    <div class="divider" id="divider-labor"></div>

    <!-- 3. Labor (collapsed by default) -->
    <div class="group section-collapsed" id="section-labor">
      <div class="collapsible-header" onclick="toggleSection('section-labor')">
        <div class="group-label">Labor</div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="btn-row">
          <button id="btn-labor-implicit" class="active" onclick="setLabor('implicit')">Implicit (self)</button>
          <button id="btn-labor-commodity" onclick="setLabor('commodity')">Commodity (t<sub>r</sub>)</button>
        </div>
        <div class="desc" id="labor-desc">Each producer adds their own labor. No money exchanged for labor.</div>
        <div class="group" id="labor-slider-group" style="display:none;flex-direction:column;gap:4px;margin-top:6px;">
          <div class="group-label" style="font-size:13px;">
            t<sub>r</sub> / value-added &mdash; <span id="tr-pct">100</span>%
          </div>
          <input type="range" id="trSlider" min="50" max="100" value="100" step="5"
                 oninput="updateTrSlider()" style="width:100%;accent-color:#3fb950;" />
          <div class="desc" id="tr-desc">Simple reproduction: t&#7523; = value-added, no surplus (s=0).</div>
        </div>
      </div>
    </div>

    <div class="divider" id="divider-leontief"></div>

    <!-- 4. Leontief Technology A -->
    <div class="group" id="section-leontief">
      <div class="group-label">Leontief Technology A</div>
      <div class="desc" id="leontief-summary"></div>
      <button onclick="openLeontiefEditor()">Edit Matrix</button>
    </div>

    <div class="divider" id="expanded-params-divider" style="display:none"></div>

    <!-- Expanded Reproduction -->
    <div class="group" id="section-expanded-params" style="display:none">
      <div class="group-label">Reproduction (2-sector) &mdash; &sect;22</div>
      <div class="desc" style="font-size:12px;">Dept I (&tau;) + Dept II (&sigma;). &tau; = means of production, &sigma; = means of subsistence. &sect;22.8</div>
      <button onclick="openExpandedParamsModal()">Configure</button>
      <div style="margin-top:6px;">
        <div class="group-label" style="font-size:11px;">Departmental Accounting</div>
        <div style="font-family:'SF Mono',Consolas,monospace;font-size:11px;line-height:1.6;">
          <div style="color:#e06c75;">Dept I (&tau;): c&#x2081;=<span id="dept-I-c">0</span> v&#x2081;=<span id="dept-I-v">0</span> &delta;&#x2081;=<span id="dept-I-s">0</span> out=<span id="dept-I-out">0</span></div>
          <div style="color:#3fb950;">Dept II (&sigma;): c&#x2082;=<span id="dept-II-c">0</span> v&#x2082;=<span id="dept-II-v">0</span> &delta;&#x2082;=<span id="dept-II-s">0</span> out=<span id="dept-II-out">0</span></div>
          <div style="color:#b1bac4;">&lambda;=<span id="dept-lambda">0</span>% &epsilon;=<span id="dept-epsilon">0</span>% &kappa;=<span id="dept-kappa">0</span>%</div>
          <div style="color:#56d4dd;">c/v=<span id="dept-organic">0</span></div>
          <div style="color:#ff69b4;font-size:10px;" id="dept-profit-rates">r&#x2081;=0% r&#x2082;=0% r&#x304;=0%</div>
          <div style="color:#8b949e;font-size:10px;">p(&tau;)=<span id="dept-pK">0</span> p(&sigma;)=<span id="dept-pC">0</span></div>
          <div style="color:#8b949e;font-size:10px;display:none;" id="dept-val-prices"></div>
        </div>
      </div>
    </div>

    <div class="divider" id="capital-forms-divider" style="display:none"></div>

    <!-- Capital Sub-Modes -->
    <div class="group" id="section-capital-forms" style="display:none">
      <div class="group-label">Capital Forms</div>
      <div class="desc" id="capital-forms-desc">No sub-modes active.</div>
      <button onclick="openCapitalModal()">Configure</button>
    </div>

    <div class="divider"></div>

    <!-- Presets -->
    <div class="group section-collapsed" id="section-presets">
      <div class="collapsible-header" onclick="toggleSection('section-presets')">
        <div class="group-label">Presets</div>
        <span class="collapse-arrow">&#x25BC;</span>
      </div>
      <div class="collapsible-body">
        <div class="preset-input-row">
          <input type="text" id="preset-name-input" placeholder="Preset name&hellip;" oninput="document.getElementById('btn-save-preset').disabled=!this.value.trim()" onkeydown="if(event.key==='Enter'&&this.value.trim())savePreset()">
          <button id="btn-save-preset" onclick="savePreset()" disabled>Save</button>
        </div>
        <div class="preset-list" id="preset-list"></div>
      </div>
    </div>
  </div>

  <!-- ── Canvas column ── -->
  <div class="canvas-col">

    <div class="circ-wrap">
      <canvas id="world"></canvas>
      <!-- Floating log -->
      <div class="log-overlay" id="logOverlay">
        <div class="log-hdr">
          <span onclick="toggleLog()" style="cursor:pointer;">Transaction Log</span>
          <span id="logCopy" onclick="event.stopPropagation();copyLog()" style="cursor:pointer;font-size:11px;color:#b1bac4;padding:0 4px;" title="Copy log">&#x2398;</span>
          <span style="flex:1;" onclick="toggleLog()"></span>
          <span id="logToggle" onclick="toggleLog()" style="cursor:pointer;">&#x25BC;</span>
        </div>
        <div class="log-entries" id="log"></div>
      </div>
      <!-- Legend overlay -->
      <div class="legend-overlay" id="legendOverlay">
        <div class="log-hdr" onclick="toggleLegend()">
          <span>Legend</span>
          <span id="legendToggle">&#x25BC;</span>
        </div>
        <div class="legend-body">
          <div class="legend-section-title">Node</div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#f8fafc;font-weight:700;">O&#x2081;</span>
            <span class="legend-text"><b>Name</b> &mdash; proprietor identity</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#9dd3ff;font-family:'SF Mono',Consolas,monospace;font-size:11px;">m=</span>
            <span class="legend-text"><b>Money</b> &mdash; monetary holdings</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon"><span style="display:inline-block;width:18px;height:4px;border-radius:2px;background:linear-gradient(90deg,#f0883e,#e06c75,#9ea5b0);"></span></span>
            <span class="legend-text"><b>Arcs</b> &mdash; inventory (goods owned)</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#f5a76e;">3.2</span>
            <span class="legend-text"><b>Total</b> &mdash; goods quantity below node</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#6e7681;">&#x1F446;</span>
            <span class="legend-text"><b>Click node</b> to inject money</span>
          </div>

          <div class="legend-section-title">Events</div>
          <div class="legend-row">
            <span class="legend-icon"><span style="display:inline-block;width:16px;height:2px;background:#fff;position:relative;top:-1px;"></span></span>
            <span class="legend-text"><b style="color:#fff;">Exchange</b> &mdash; white arrows between buyer and seller</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#3fb950;">&#x25CB;</span>
            <span class="legend-text"><b style="color:#3fb950;">Production</b> &mdash; green ring expands from producer</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#79c0ff;font-size:11px;font-family:'SF Mono',Consolas,monospace;">&#x2191;&#x2193;</span>
            <span class="legend-text"><b style="color:#79c0ff;">Receipt</b> &mdash; &#x2191;gained &#x2193;lost per owner (exchange and production)</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon" style="color:#d2a8ff;">&#x25CF;</span>
            <span class="legend-text"><b style="color:#d2a8ff;">Profit</b> &mdash; purple dots along M&#x2192;C&#x2192;M&#x2032; circuit</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon">&#x26F5;</span>
            <span class="legend-text"><b style="color:#ff9f43;">Merchant</b> &mdash; ship sails in from abroad with Sp</span>
          </div>
          <div class="legend-row">
            <span class="legend-icon"><span style="display:inline-block;width:16px;height:5px;background:#ffd700;border-radius:2px;position:relative;top:-1px;"></span></span>
            <span class="legend-text"><b style="color:#ffd700;">Usury</b> &mdash; gold channel (thins as debt repaid)</span>
          </div>
        </div>
      </div>
      <!-- Recipe toast -->
      <div class="recipe-toast" id="recipeToast"></div>
    </div>

    <div class="legend-bar" id="chart-legend"></div>

    <div class="chart-strip">
      <canvas id="chart"></canvas>
      <div id="chartTooltip" style="display:none;position:absolute;pointer-events:none;
        background:#161b22ee;border:1px solid #30363d;border-radius:4px;padding:3px 7px;
        font:11px 'SF Mono',Consolas,monospace;color:#e6edf3;white-space:nowrap;z-index:10;"></div>
    </div>
  </div>
</div>

<!-- Leontief Editor Modal -->
<div class="modal-overlay hidden" id="leontiefModal" onclick="if(event.target===this)closeLeontiefEditor()">
  <div class="modal">
    <div class="modal-header">
      <h2>Leontief Technology Matrix</h2>
      <button class="modal-close" onclick="closeLeontiefEditor()">&times;</button>
    </div>
    <div class="desc" style="margin-bottom:14px;font-size:14px;">
      Edit input coefficients and commodities. Column sums &lt; 1 &rArr; productive economy.
    </div>
    <div class="tech-matrix" id="techMatrix"></div>
  </div>
</div>

<!-- Capital Sub-Modes Modal -->
<div class="modal-overlay hidden" id="capitalModal" onclick="if(event.target===this)closeCapitalModal()">
  <div class="modal">
    <div class="modal-header">
      <h2>Capital Sub-Modes</h2>
      <button class="modal-close" onclick="closeCapitalModal()">&times;</button>
    </div>

    <!-- Merchant Capital -->
    <div style="margin-bottom:18px;">
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
        <span style="font-weight:700;font-size:15px;color:#ff9f43;">Merchant Capital</span>
        <button id="btn-merchant-on" onclick="setMerchantCapital(true)">On</button>
        <button id="btn-merchant-off" class="active" onclick="setMerchantCapital(false)">Off</button>
      </div>
      <div class="desc" style="font-size:13px;margin-bottom:8px;">
        Buy domestic goods, trade abroad 1:1 for foreign spice (Sp), sell domestically. Sp has higher value than domestic goods, so the merchant realizes a monetary profit from the value asymmetry.
      </div>
      <div class="desc" style="font-size:12px;color:#6e7681;margin-bottom:8px;font-style:italic;">
        Increases total value V and MELT, but only because it appropriates value produced in a foreign CC &mdash; no new value is created within this circuit.
      </div>
      <div id="merchant-owners" style="margin-bottom:8px;"></div>
      <div id="merchant-rates-container" style="display:none;">
        <div class="group-label" style="font-size:12px;margin-bottom:4px;">Value of 1 Sp relative to 1 unit of domestic good</div>
        <div id="merchant-rates-table" class="tech-matrix"></div>
      </div>
    </div>

    <div style="border-top:1px solid #30363d;margin:12px 0;"></div>

    <!-- Usury Capital -->
    <div style="margin-bottom:18px;">
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
        <span style="font-weight:700;font-size:15px;color:#ffd700;">Usury Capital</span>
        <button id="btn-usury-on" onclick="setUsuryCapital(true)">On</button>
        <button id="btn-usury-off" class="active" onclick="setUsuryCapital(false)">Off</button>
      </div>
      <div class="desc" style="font-size:13px;margin-bottom:8px;">
        Rich proprietors lend money to cash-poor ones. Interest absorbs value from debtors over time.
      </div>
      <div class="desc" style="font-size:12px;color:#6e7681;margin-bottom:8px;font-style:italic;">
        Does not change total value V or MELT. Usury only redistributes existing money between proprietors &mdash; it is parasitic on value already in circulation.
      </div>
      <div id="usury-owners" style="margin-bottom:8px;"></div>
      <div id="usury-settings" style="display:none;">
        <div style="margin-bottom:8px;">
          <div class="group-label" style="font-size:12px;">Interest rate &mdash; <span id="usury-rate-pct">10</span>%</div>
          <input type="range" id="usuryRateSlider" min="5" max="50" value="10" step="1"
                 oninput="updateUsuryRate()" style="width:100%;accent-color:#ffd700;">
        </div>
        <div>
          <div class="group-label" style="font-size:12px;">Installment ratio &mdash; <span id="usury-install-pct">15</span>%</div>
          <input type="range" id="usuryInstallSlider" min="5" max="40" value="15" step="1"
                 oninput="updateUsuryInstallment()" style="width:100%;accent-color:#ffd700;">
          <div class="desc" style="font-size:12px;">Fraction of debtor's money paid per step toward loan.</div>
        </div>
      </div>
    </div>

    <div style="border-top:1px solid #30363d;margin:12px 0;"></div>

    <!-- Industrial Capital -->
    <div>
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
        <span style="font-weight:700;font-size:15px;color:#e06c75;">Industrial Capital</span>
        <button id="btn-industrial-on" onclick="setIndustrialCapital(true)">On</button>
        <button id="btn-industrial-off" class="active" onclick="setIndustrialCapital(false)">Off</button>
      </div>
      <div class="desc" style="font-size:13px;margin-bottom:8px;">
        Forces commodity labor mode: surplus value extracted from production. Disables implicit labor toggle.
      </div>
      <div id="industrial-owners" style="margin-bottom:8px;"></div>
      <div class="desc" style="font-size:12px;color:#6e7681;font-style:italic;">
        Increases V and MELT through labor&rsquo;s value-added in production. The t&#7523; slider controls how surplus is distributed: at 100% the laborer receives the full value-added (no surplus appropriated); below 100% the producer retains the difference as surplus value s.
      </div>
    </div>
  </div>
</div>

<!-- Expanded Reproduction Parameters Modal -->
<div class="modal-overlay hidden" id="expandedParamsModal" onclick="if(event.target===this)closeExpandedParamsModal()">
  <div class="modal" autocomplete="off">
    <div class="modal-header">
      <h2>Reproduction Parameters</h2>
      <button class="modal-close" onclick="closeExpandedParamsModal()">&times;</button>
    </div>
    <div class="desc" style="margin-bottom:14px;font-size:14px;">
      Two-department reproduction (&sect;22.8). Dept I produces &tau; (means of production), Dept II produces &sigma; (means of subsistence). Each &theta;-cycle, surplus &delta; is split into reinvestment c<sub>n+1</sub>+v<sub>n+1</sub> and revenue r<sub>n</sub> via the allocation &alpha;<sup>k</sup> (&sect;22.1.4).
    </div>
    <div style="display:flex;flex-direction:column;gap:10px;">
      <div>
        <div class="group-label" style="font-size:13px;">Reinvestment share &lambda; &mdash; <span id="accum-rate-pct">50</span>% <span style="font-size:11px;color:#8b949e;">&sect;22.2</span></div>
        <input type="range" id="accumRateSlider" min="0" max="100" value="50" step="5"
               oninput="updateAccumRate()" style="width:100%;accent-color:#ffa060;">
        <div class="desc" style="font-size:12px;">&lambda;=0: simple reproduction, all surplus consumed as revenue r=&delta; (&sect;22.2.3). &lambda;&gt;0: expanded reproduction, &tau; stocks grow each cycle. Accumulation rate &kappa;=&lambda;&epsilon;.</div>
      </div>
      <div>
        <div class="group-label" style="font-size:13px;">Rate of exploitation &epsilon; = t<sub>s</sub>/t<sub>r</sub> &mdash; <span id="exploit-rate-pct">100</span>% <span style="font-size:11px;color:#8b949e;">&sect;17.5</span></div>
        <input type="range" id="exploitRateSlider" min="10" max="300" value="100" step="10"
               oninput="updateExploitRate()" style="width:100%;accent-color:#ffa060;">
        <div class="desc" style="font-size:12px;">Ratio of surplus labor-time to necessary labor-time. Higher &epsilon; means more surplus &delta; per worker hired, increasing both revenue and reinvestment.</div>
      </div>
      <div>
        <div class="group-label" style="font-size:13px;">Wage m<sub>w</sub> &mdash; <span id="wage-val">5</span> <span style="font-size:11px;color:#8b949e;">&sect;21.3</span></div>
        <input type="range" id="wageSlider" min="1" max="20" value="5" step="1"
               oninput="updateWage()" style="width:100%;accent-color:#ffa060;">
        <div class="desc" style="font-size:12px;">Variable capital v per worker. Enters value-price formulas: p(&tau;)&nbsp;=&nbsp;m<sub>w</sub>(1+&epsilon;)/(1&minus;a<sub>&tau;&tau;</sub>). Higher wages raise commodity prices and shift organic composition c/v.</div>
      </div>
      <div style="border-top:1px solid #30363d;margin:4px 0;padding-top:4px;">
        <div class="desc" style="font-size:12px;color:#8b949e;margin-bottom:6px;">Technical coefficients (Leontief input&ndash;output). These determine the organic composition c/v: higher coefficients mean more constant capital per unit of output, raising c/v and concentrating reinvestment in &tau; rather than wages.</div>
      </div>
      <div>
        <div class="group-label" style="font-size:13px;">a<sub>&tau;&tau;</sub> Dept I &mdash; <span id="coeff-ki-val">0.4</span></div>
        <input type="range" id="coeffKISlider" min="0.1" max="0.9" value="0.4" step="0.05"
               oninput="updateExpandedCoeffs()" style="width:100%;accent-color:#e06c75;">
        <div class="desc" style="font-size:12px;">Units of &tau; consumed to produce one unit of &tau;. Dept I&rsquo;s self-consumption: net output available for sale is (1&minus;a<sub>&tau;&tau;</sub>) per unit produced.</div>
      </div>
      <div>
        <div class="group-label" style="font-size:13px;">a<sub>&sigma;&tau;</sub> Dept II &mdash; <span id="coeff-kii-val">0.6</span></div>
        <input type="range" id="coeffKIISlider" min="0.1" max="0.9" value="0.6" step="0.05"
               oninput="updateExpandedCoeffs()" style="width:100%;accent-color:#3fb950;">
        <div class="desc" style="font-size:12px;">Units of &tau; consumed to produce one unit of &sigma;. Dept II&rsquo;s dependence on Dept I: higher values mean Dept II must buy more &tau; each cycle.</div>
      </div>
      <div style="border-top:1px solid #30363d;margin:4px 0;padding-top:4px;">
        <div class="desc" style="font-size:12px;color:#8b949e;margin-bottom:6px;">Technical change (&sect;22.6.5). Capitalists adopt more capital-intensive techniques to raise productivity, increasing &tau; coefficients over time. This drives rising organic composition c/v and the tendency of the profit rate to fall.</div>
      </div>
      <div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:13px;cursor:pointer;display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="techChangeToggle" onchange="toggleTechChange()" style="accent-color:#ffa060;">
            Technical change
          </label>
          <span id="tech-change-status" style="font-size:11px;color:#8b949e;">off</span>
        </div>
        <div id="techChangeRateGroup" style="margin-top:6px;display:none;">
          <div class="group-label" style="font-size:13px;">&Delta;a per &theta;-cycle &mdash; <span id="tech-change-rate-val">0.005</span></div>
          <input type="range" id="techChangeRateSlider" min="0.001" max="0.02" value="0.005" step="0.001"
                 oninput="updateTechChangeRate()" style="width:100%;accent-color:#ffa060;">
          <div class="desc" style="font-size:12px;">Absolute increase in both a<sub>&tau;&tau;</sub> and a<sub>&sigma;&tau;</sub> each cycle. At 0.005/tick from defaults (0.4, 0.6), coefficients reach 0.9 in ~60&ndash;100 ticks.</div>
        </div>
      </div>
      <div style="border-top:1px solid #30363d;margin:4px 0;padding-top:4px;">
        <div class="desc" style="font-size:12px;color:#8b949e;margin-bottom:6px;">Prices of production (&sect;Vol. III). Competition redistributes surplus so all departments earn a uniform profit rate r&#x304;, causing prices to deviate from labor values.</div>
      </div>
      <div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:13px;cursor:pointer;display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="prodPricesToggle" onchange="toggleProdPrices()" style="accent-color:#ff69b4;">
            Prices of production
          </label>
          <span id="prod-prices-status" style="font-size:11px;color:#8b949e;">off</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// DYNAMIC MODEL: CC, Depletion, Stabilizer, Capital, Expanded Reproduction
// Continuous-quantity model (fractional goods, Leontief I/O)
// ============================================================

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chart');
const chartCtx = chartCanvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

// ── Constants ──
const UNIT_PRICE = 5;
const EXCHANGE_QTY_MIN = 0.3;
const EXCHANGE_QTY_MAX = 0.8;
const CONSUME_QTY_MIN = 0.05;
const CONSUME_QTY_MAX = 0.15;
const PROD_SCALE_MAX = 1.5;
const DEATH_THRESHOLD = 0.01;

// ── State ──
let mode = 'cc';
let prodMode = 'conservative';
let playing = false;
let tick = 0;
let exchangeCount = 0;
let productionCount = 0;
let surplusAccumulated = 0;
let proprietors = [];
let animations = [];
let gHistory = [];
let vHistory = [];
let mHistory = [];
let ownerValueHistories = [];
let prodPerTickHistory = [];
let consPerTickHistory = [];
let arbCumHistory = [];
let surplusCumHistory = [];
let allowArbitrage = false;         // toggle for capital arbitrage
let recipeTimer = 0;

const OWNER_COLORS = [
  '#f0883e','#79c0ff','#3fb950','#d2a8ff','#e06c75','#56d4dd',
  '#d4a76a','#9ea5b0','#ff69b4','#ffd700','#b87333','#32cd32',
];
let targetG = 0; // Leontief equilibrium target for |G|
let laborMode = 'implicit'; // 'implicit' | 'commodity'
let trRatio = 1.0;          // t_r / value_added, from slider (0.1 to 1.0)
let surplusLabor = 0;       // cumulative surplus s from production
let coupleExchangeConsumption = true;  // couple exchange with consumption
let currentConsRate = 0.055;           // updated each step by stabilizer
let stepConsumedQty = 0;              // total units consumed this step (coupled mode)
let stepProducedQty = 0;              // total units produced this step (gross output)
let stepArbQty = 0;                   // arbitrage δ this step
let stepSurplusQty = 0;              // surplus value s this step

// Capital sub-modes (independently toggleable)
let capitalSubModes = { merchant: false, usury: false, industrial: false };
// Which owners can participate in each sub-mode (sets of owner ids, default all)
let capitalEligible = { merchant: new Set(), usury: new Set(), industrial: new Set() };

// Merchant: foreign good + exchange rates
const FOREIGN_GOOD = { name: 'spice', sym: 'Sp', color: '#ff9f43' };
let merchantExchangeRates = {};  // sym → value multiplier (value of 1 Sp relative to 1 domestic good)

// Usury: loans + settings
let loans = [];  // { lenderId, borrowerId, principal, remaining, interestRate }
let usuryInterestRate = 0.10;
let usuryInstallmentRatio = 0.15;  // fraction of debtor's money per step

// ── Expanded reproduction ──
let expandedParams = {
  accumRate: 0.50,
  rateExploitation: 1.0,
  wagePerWorker: 5.0,
  numCapitalists: 2,
  techChangeEnabled: false,
  techChangeRate: 0.005,  // coefficient increase per tick (absolute)
  prodPricesEnabled: false,
};

let deptAccounting = {
  I:  { c:0, v:0, s:0, output:0 },
  II: { c:0, v:0, s:0, output:0 },
};

// Value-based prices for expanded mode (derived from Leontief coefficients + wages)
let expandedPrices = { '\u03C4': 5, '\u03C3': 5 };  // τ, σ
let valuePrices = { '\u03C4': 5, '\u03C3': 5 };  // always tracks labor-value prices for comparison
let organicCompHistory = [];  // c/v ratio history for chart
let kappaHistory = [];  // accumulation rate κ = λε history
let profitRateIHistory = [];   // per-dept profit rate Dept I
let profitRateIIHistory = [];  // per-dept profit rate Dept II
let priceDevTauHistory = [];   // pp(τ)/value(τ) ratio
let priceDevSigHistory = [];   // pp(σ)/value(σ) ratio
let normDevTauHistory = [];    // normalized: pp/val(τ) ÷ mean(pp/val), redistribution component
let normDevSigHistory = [];    // normalized: pp/val(σ) ÷ mean(pp/val), redistribution component

function getCoeffs() {
  // Source of truth: LEONTIEF_RECIPES (updated by sliders and technical change)
  const rK = (typeof LEONTIEF_RECIPES !== 'undefined') && LEONTIEF_RECIPES.find(r=>r.output==='\u03C4');
  const rC = (typeof LEONTIEF_RECIPES !== 'undefined') && LEONTIEF_RECIPES.find(r=>r.output==='\u03C3');
  return {
    a_tt: rK ? rK.coeffs[0] : 0.4,   // a_ττ (Dept I)
    a_st: rC ? rC.coeffs[0] : 0.6,   // a_στ (Dept II)
  };
}
function computeExpandedPrices() {
  const w = expandedParams.wagePerWorker;
  const e = expandedParams.rateExploitation;
  const { a_tt, a_st } = getCoeffs();
  // Value prices: p(τ) = w(1+ε) / (1 - a_ττ), p(σ) = a_στ · p(τ) + w(1+ε)
  const laborCost = w * (1 + e);
  valuePrices['\u03C4'] = (1 - a_tt) > 0.01 ? laborCost / (1 - a_tt) : laborCost * 10;
  valuePrices['\u03C3'] = a_st * valuePrices['\u03C4'] + laborCost;

  if (expandedParams.prodPricesEnabled && profitRateHistory.length > 0) {
    // Production prices: pp(τ) = (1+r̄)·w / (1 - (1+r̄)·a_ττ)
    // pp(σ) = (1+r̄)·(a_στ · pp(τ) + w)
    const rBar = profitRateHistory[profitRateHistory.length - 1];
    const denom = 1 - (1 + rBar) * a_tt;
    if (denom > 0.01) {
      expandedPrices['\u03C4'] = (1 + rBar) * w / denom;
      expandedPrices['\u03C3'] = (1 + rBar) * (a_st * expandedPrices['\u03C4'] + w);
    } else {
      // Fallback to value prices if denominator too small
      expandedPrices['\u03C4'] = valuePrices['\u03C4'];
      expandedPrices['\u03C3'] = valuePrices['\u03C3'];
    }
  } else {
    // Use value prices
    expandedPrices['\u03C4'] = valuePrices['\u03C4'];
    expandedPrices['\u03C3'] = valuePrices['\u03C3'];
  }
}

function goodPrice(sym) {
  if (mode === 'expanded' && expandedPrices[sym] !== undefined) return expandedPrices[sym];
  return UNIT_PRICE;
}

let deptIOutputHistory = [];
let deptIIOutputHistory = [];
let profitRateHistory = [];
let capitalStockHistory = [];

// Per-step accumulators
let stepMerchantProfit = 0;
let stepLoanInterest = 0;

// Cumulative history for charts
let merchantCumHistory = [];
let usuryCumHistory = [];
let mevHistory = [];  // monetary expression of value: M/V

// Chart series visibility (all on by default)
const CHART_SERIES = [
  { key:'goods',    color:'#f0883e', legendLabel:'Goods',       modes:['cc','simple'] },
  { key:'value',    color:'#79c0ff', legendLabel:'Value',       modes:['cc','simple'] },
  { key:'share',    color:'#8b949e', legendLabel:'Value share', modes:['cc','simple'] },
  { key:'produced', color:'#3fb950', legendLabel:'Production',  modes:['cc','simple'] },
  { key:'consumed', color:'#da3633', legendLabel:'Consumption', modes:['cc','simple'] },
  { key:'arbitrage',color:'#d2a8ff', legendLabel:'Arbitrage',   modes:['cc','simple'] },
  { key:'surplus',  color:'#e06c75', legendLabel:'Surplus',     modes:['cc','simple'] },
  { key:'merchant', color:'#ff9f43', legendLabel:'Merchant',    modes:['cc','simple'] },
  { key:'usury',    color:'#ffd700', legendLabel:'Usury',       modes:['cc','simple'] },
  { key:'melt',     color:'#58a6ff', legendLabel:'MELT',        modes:['cc','simple'] },
  { key:'deptI',    color:'#e06c75', legendLabel:'Dept I (\u03C4)',   modes:['expanded'] },
  { key:'deptII',   color:'#3fb950', legendLabel:'Dept II (\u03C3)', modes:['expanded'] },
  { key:'profRate', color:'#d2a8ff', legendLabel:'profit rate',  modes:['expanded'] },
  { key:'capitalStock', color:'#ff9f43', legendLabel:'\u03C4 stock', modes:['expanded'] },
  { key:'organicComp', color:'#56d4dd', legendLabel:'c/v',   modes:['expanded'] },
  { key:'kappa',    color:'#ffa060', legendLabel:'\u03BA accum',  modes:['expanded'] },
  { key:'deptProfRates', color:'#d2a8ff', legendLabel:'r\u2081 vs r\u2082', modes:['expanded'] },
  { key:'priceDev', color:'#ff69b4', legendLabel:'pp/val', modes:['expanded'] },
  { key:'redist', color:'#bc8cff', legendLabel:'redist', modes:['expanded'] },
];
let chartVisible = Object.fromEntries(CHART_SERIES.map(s=>[s.key,true]));

// ── Commodity types (sectors) ──
let TYPES = [
  { name:'wheat', color:'#f0883e', sym:'W' },
  { name:'cloth', color:'#e06c75', sym:'Cl'},
];
let N_SECTORS = TYPES.length;

// Pool of extra commodities for the "Add" button
const COMMODITY_POOL = [
  { name:'iron',  sym:'Fe', color:'#9ea5b0' },
  { name:'wine',  sym:'Vi', color:'#bc8cff' },
  { name:'wood',  sym:'Wd', color:'#a67c52' },
  { name:'salt',  sym:'Sa', color:'#d0d0d0' },
  { name:'fish',  sym:'Fi', color:'#56d4dd' },
  { name:'bread', sym:'Br', color:'#d4a76a' },
  { name:'coal',  sym:'Co', color:'#777777' },
  { name:'gold',  sym:'Au', color:'#ffd700' },
  { name:'silk',  sym:'Si', color:'#ff69b4' },
  { name:'oil',   sym:'Oi', color:'#4a7a3a' },
  { name:'corn',  sym:'Cn', color:'#e8d44d' },
  { name:'copper',sym:'Cu', color:'#b87333' },
  { name:'tea',   sym:'Te', color:'#567d46' },
  { name:'tin',   sym:'Sn', color:'#8b8b83' },
  { name:'sugar', sym:'Su', color:'#f5f5dc' },
  { name:'lime',  sym:'Li', color:'#32cd32' },
];

// ═══════════════════════════════════════════════════════════════
// LEONTIEF INPUT–OUTPUT SYSTEM
// One canonical recipe per sector. Each takes 2 inputs → 1 output.
// The economy is fully circular: every good is both produced and consumed.
// ═══════════════════════════════════════════════════════════════
let LEONTIEF_RECIPES = [
  { output:'W',  inputs:['Cl','Cl'], coeffs:[0.4,0.4] },
  { output:'Cl', inputs:['W','W'],   coeffs:[0.4,0.4] },
];

// Defaults for restoring after expanded mode
const DEFAULT_TYPES = TYPES.map(t=>({...t}));
const DEFAULT_RECIPES = LEONTIEF_RECIPES.map(r=>({output:r.output, inputs:[...r.inputs], coeffs:[...r.coeffs]}));

function recipeLabel(r){ return r.inputs.join('+') + ' \u2192 ' + r.output; }

// Technology matrix A[i][j] = input coefficient of good i per unit of good j produced.
let LEONTIEF_A = [];
let LEONTIEF_INV = [];
let LEONTIEF_X_STAR = [];
let PROD_WEIGHTS = [];

// Compute (I−A)⁻¹ via Gauss-Jordan elimination
function invertIminusA(A){
  const n=A.length;
  if(n===0) return [];
  const aug=A.map((row,i)=>{
    const r=row.map((v,j)=>(i===j?1:0)-v);
    return [...r,...Array(n).fill(0).map((_,j)=>i===j?1:0)];
  });
  for(let c=0;c<n;c++){
    let mx=c;
    for(let r=c+1;r<n;r++) if(Math.abs(aug[r][c])>Math.abs(aug[mx][c])) mx=r;
    [aug[c],aug[mx]]=[aug[mx],aug[c]];
    const piv=aug[c][c];
    if(Math.abs(piv)<1e-12) continue; // singular guard
    for(let j=0;j<2*n;j++) aug[c][j]/=piv;
    for(let r=0;r<n;r++){
      if(r===c)continue;
      const f=aug[r][c];
      for(let j=0;j<2*n;j++) aug[r][j]-=f*aug[c][j];
    }
  }
  return aug.map(row=>row.slice(n));
}

// Rebuild all derived Leontief structures from TYPES + LEONTIEF_RECIPES
function rebuildLeontief(){
  N_SECTORS = TYPES.length;
  // Build A matrix from recipes
  LEONTIEF_A = Array.from({length:N_SECTORS}, ()=>Array(N_SECTORS).fill(0));
  for (const r of LEONTIEF_RECIPES){
    const j = TYPES.findIndex(t=>t.sym===r.output);
    if(j<0) continue;
    for (let k=0; k<r.inputs.length; k++){
      const i = TYPES.findIndex(t=>t.sym===r.inputs[k]);
      if(i>=0) LEONTIEF_A[i][j] = r.coeffs[k];
    }
  }
  // Compute inverse
  LEONTIEF_INV = invertIminusA(LEONTIEF_A);
  // Equilibrium gross output for uniform demand d=[1,...,1]
  const d = Array(N_SECTORS).fill(1);
  LEONTIEF_X_STAR = LEONTIEF_INV.map(row=>row.reduce((s,v,j)=>s+v*d[j],0));
  const xSum = LEONTIEF_X_STAR.reduce((s,v)=>s+v,0);
  PROD_WEIGHTS = xSum>0 ? LEONTIEF_X_STAR.map(v=>v/xSum) : Array(N_SECTORS).fill(1/N_SECTORS);
  // Update displays
  renderEditableMatrix();
  updateLeontiefSummary();
}

function typeBySymbol(s) { return TYPES.find(t => t.sym === s) || (s === FOREIGN_GOOD.sym ? FOREIGN_GOOD : undefined); }

// ── Proprietor (continuous inventory) ──
class Proprietor {
  constructor(id, x, y) {
    this.id = id;
    this.name = `O\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089`[id+1] ? `O${String.fromCharCode(0x2080+id+1)}` : `O${id+1}`;
    this.label = `O${id+1}`;
    this.x = x; this.y = y;
    this.money = 0;
    this.inventory = {}; // sym → quantity (continuous)
    this.role = 'idle';
    this.roleTimer = 0;
    this.isCapitalist = false;
    this.capitalSurplus = 0;
    this.dead = false;
    this.agentClass = 'worker';
    this.department = 0;
    this.wageIncome = 0;
    this.profitIncome = 0;
  }
  totalGoods() {
    return Object.values(this.inventory).reduce((s, q) => s + q, 0);
  }
  addGoods(sym, qty) {
    this.inventory[sym] = (this.inventory[sym] || 0) + qty;
  }
  removeGoods(sym, qty) {
    if (!this.inventory[sym]) return 0;
    const removed = Math.min(this.inventory[sym], qty);
    this.inventory[sym] -= removed;
    if (this.inventory[sym] < DEATH_THRESHOLD) delete this.inventory[sym];
    return removed;
  }
  randomGoodType() {
    const entries = Object.entries(this.inventory).filter(([_, q]) => q > DEATH_THRESHOLD);
    if (!entries.length) return null;
    const total = entries.reduce((s, [_, q]) => s + q, 0);
    let r = Math.random() * total;
    for (const [sym, qty] of entries) {
      r -= qty;
      if (r <= 0) return sym;
    }
    return entries[entries.length - 1][0];
  }
  totalValue() {
    let goodsVal = 0;
    for (const [sym, qty] of Object.entries(this.inventory)) {
      if (qty < DEATH_THRESHOLD) continue;
      if (sym === FOREIGN_GOOD.sym) {
        const rates = Object.values(merchantExchangeRates);
        const avgRate = rates.length ? rates.reduce((s,r)=>s+r,0)/rates.length : 1.5;
        goodsVal += qty * goodPrice(sym) * avgRate;
      } else {
        goodsVal += qty * goodPrice(sym);
      }
    }
    return this.money + goodsVal;
  }
  goodsValue() {
    let gv = 0;
    for (const [sym, qty] of Object.entries(this.inventory)) {
      if (qty < DEATH_THRESHOLD) continue;
      if (sym === FOREIGN_GOOD.sym) {
        const rates = Object.values(merchantExchangeRates);
        const avgRate = rates.length ? rates.reduce((s,r)=>s+r,0)/rates.length : 1.5;
        gv += qty * goodPrice(sym) * avgRate;
      } else {
        gv += qty * goodPrice(sym);
      }
    }
    return gv;
  }
  checkDeath() {
    if (!this.dead && this.money < DEATH_THRESHOLD && this.totalGoods() < DEATH_THRESHOLD) {
      if (laborMode === 'commodity') return; // can still work for wages
      this.dead = true;
      this.role = 'dead';
      logEntry('system',`\uD83D\uDC80 ${this.label} eliminated \u2014 no money, no goods.`);
    }
  }
}

// ── Init ──
let _wasExpandedMode = false;
function init() {
  // Restore default TYPES/recipes when leaving expanded mode
  if (_wasExpandedMode && mode !== 'expanded') {
    TYPES = DEFAULT_TYPES.map(t=>({...t}));
    LEONTIEF_RECIPES = DEFAULT_RECIPES.map(r=>({output:r.output, inputs:[...r.inputs], coeffs:[...r.coeffs]}));
    rebuildLeontief();
  }
  _wasExpandedMode = (mode === 'expanded');

  const n = +document.getElementById('numProprietors').value;
  const initC = +document.getElementById('initCommodities').value;
  proprietors = []; animations = [];
  tick=0; exchangeCount=0; productionCount=0; surplusAccumulated=0; surplusLabor=0;
  gHistory=[]; vHistory=[]; mHistory=[]; ownerValueHistories=[];
  prodPerTickHistory=[]; consPerTickHistory=[]; arbCumHistory=[]; surplusCumHistory=[];
  loans=[]; merchantCumHistory=[]; usuryCumHistory=[]; mevHistory=[];
  deptIOutputHistory=[]; deptIIOutputHistory=[]; profitRateHistory=[]; capitalStockHistory=[]; organicCompHistory=[]; kappaHistory=[];
  profitRateIHistory=[]; profitRateIIHistory=[]; priceDevTauHistory=[]; priceDevSigHistory=[]; normDevTauHistory=[]; normDevSigHistory=[];
  valuePrices = { '\u03C4': 5, '\u03C3': 5 };
  deptAccounting = { I:{c:0,v:0,s:0,output:0}, II:{c:0,v:0,s:0,output:0} };
  merchantExchangeRates = {};
  for (const t of TYPES) merchantExchangeRates[t.sym] = 1.5;
  // Reset capital eligibility — all owners eligible by default
  capitalEligible = { merchant: new Set(), usury: new Set(), industrial: new Set() };

  const cx = canvas.width/(2*DPR);
  const cy = canvas.height/(2*DPR);
  const radius = Math.min(cx,cy)*0.73;

  for (let i=0;i<n;i++){
    const a = 2*Math.PI*i/n - Math.PI/2;
    const p = new Proprietor(i, cx+radius*Math.cos(a), cy+radius*Math.sin(a));
    p.money = 12+Math.floor(Math.random()*8);
    // Distribute initC total units across random types
    let remaining = initC;
    while (remaining > 0.01) {
      const sym = TYPES[Math.floor(Math.random()*TYPES.length)].sym;
      const chunk = Math.min(remaining, 0.3 + Math.random()*1.2);
      p.addGoods(sym, chunk);
      remaining -= chunk;
    }
    if (mode==='simple' && i===0){ p.isCapitalist=true; p.money=40; }
    proprietors.push(p);
  }

  // ── Expanded mode init ──
  if (mode === 'expanded') {
    laborMode = 'commodity';
    prodMode = 'conservative';
    TYPES = [
      { name:'means of production', color:'#e06c75', sym:'\u03C4' },
      { name:'means of subsistence', color:'#3fb950', sym:'\u03C3' },
    ];
    // Read coefficients from modal sliders (or use defaults)
    const kiSlider = document.getElementById('coeffKISlider');
    const kiiSlider = document.getElementById('coeffKIISlider');
    const coeffKI = kiSlider ? +kiSlider.value : 0.4;
    const coeffKII = kiiSlider ? +kiiSlider.value : 0.6;
    LEONTIEF_RECIPES = [
      { output:'\u03C4', inputs:['\u03C4'], coeffs:[coeffKI] },
      { output:'\u03C3', inputs:['\u03C4'], coeffs:[coeffKII] },
    ];
    rebuildLeontief();
    computeExpandedPrices();

    const nCap = expandedParams.numCapitalists; // always 2
    // Initial endowment scaled to value-prices so capitalists can afford ~2 production cycles
    const initK = 4;
    const initCapMoney = initK * expandedPrices['\u03C4'] + expandedParams.wagePerWorker * 4;
    const initWorkerMoney = expandedParams.wagePerWorker * 2;
    // Assign classes: 1 capitalist per department, workers are a shared labor pool
    for (let i = 0; i < proprietors.length; i++) {
      const p = proprietors[i];
      if (i < nCap) {
        p.agentClass = 'capitalist';
        p.isCapitalist = true;
        p.department = i === 0 ? 1 : 2; // O\u2081 = Dept I, O\u2082 = Dept II
        p.money = initCapMoney;
        p.inventory = { '\u03C4': initK };
      } else {
        p.agentClass = 'worker';
        p.isCapitalist = false;
        p.department = 0; // shared pool — hired by either department each tick
        p.money = initWorkerMoney;
        p.inventory = { '\u03C3': 2 };
      }
    }
    targetG = Infinity;
  } else {
    // Set Leontief target: |G| should stay at this level in conservative mode
    targetG = proprietors.reduce((s,p)=>s+p.totalGoods(), 0);
  }

  ownerValueHistories = proprietors.map(() => []);
  // Populate capital eligibility with all owner ids
  for (const p of proprietors) {
    capitalEligible.merchant.add(p.id);
    capitalEligible.usury.add(p.id);
    capitalEligible.industrial.add(p.id);
  }

  logEntry('system',`Init ${n} proprietors, mode=${mode}, prod=${prodMode}, target |G|=${targetG.toFixed(1)}`);
  updateStats();
}

// ── Exchange helper (extracted so coupled mode can reorder) ──
function runExchanges(shuffled){
  // Process loan repayments at start of exchange phase
  if (capitalSubModes.usury) processLoanRepayments();

  for (const p of shuffled){
    p.roleTimer = Math.max(0, p.roleTimer-1);
    if (p.roleTimer>0) continue;
    // Arbitrage: any proprietor can try to buy low / sell high (price ≠ value)
    if (allowArbitrage && p.money>=5 && Math.random()<0.15){ attemptCapital(p); continue; }
    if (capitalSubModes.merchant && capitalEligible.merchant.has(p.id) && p.money>=5 && Math.random()<0.12){ attemptMerchantCapital(p); continue; }
    if (capitalSubModes.usury && capitalEligible.usury.has(p.id) && p.money>=10 && Math.random()<0.20){ attemptUsury(p); continue; }
    if (p.money>0 && Math.random()<0.5) attemptBuy(p);
    else if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<0.4) attemptSell(p);
  }
}

// ── Expanded reproduction step ──
function stepExpanded(){
  tick++;
  stepConsumedQty = 0;
  stepProducedQty = 0;
  stepArbQty = 0;
  stepSurplusQty = 0;
  stepMerchantProfit = 0;
  stepLoanInterest = 0;

  // Technical change (§22.6.5): coefficients rise each θ-cycle
  if (expandedParams.techChangeEnabled) {
    const rate = expandedParams.techChangeRate;
    const maxCoeff = 0.95;
    const rK = LEONTIEF_RECIPES.find(r=>r.output==='\u03C4');
    const rC = LEONTIEF_RECIPES.find(r=>r.output==='\u03C3');
    if (rK) {
      const newKI = Math.min(maxCoeff, rK.coeffs[0] + rate);
      rK.coeffs[0] = newKI;
      const kiSlider = document.getElementById('coeffKISlider');
      if (kiSlider) kiSlider.value = newKI;
      document.getElementById('coeff-ki-val').textContent = newKI.toFixed(3);
    }
    if (rC) {
      const newKII = Math.min(maxCoeff, rC.coeffs[0] + rate);
      rC.coeffs[0] = newKII;
      const kiiSlider = document.getElementById('coeffKIISlider');
      if (kiiSlider) kiiSlider.value = newKII;
      document.getElementById('coeff-kii-val').textContent = newKII.toFixed(3);
    }
  }

  // Recompute value-based prices each tick (in case params changed)
  computeExpandedPrices();
  const pTau = expandedPrices['\u03C4'];
  const pSigma = expandedPrices['\u03C3'];

  // Reset per-step accounting
  deptAccounting = { I:{c:0,v:0,s:0,output:0}, II:{c:0,v:0,s:0,output:0} };
  for (const p of proprietors) { p.wageIncome = 0; p.profitIncome = 0; p._tauConsumedThisTick = 0; }

  const alive = proprietors.filter(p => !p.dead);
  const capitalists = alive.filter(p => p.agentClass === 'capitalist');
  const workers = alive.filter(p => p.agentClass === 'worker');

  // ── Phase 1: Production (§15, §22.1) ──
  // Workers are a shared labor pool — each node is a "collective" hired by either dept.
  // Allocate workers proportionally to each capitalist's τ-constrained demand,
  // then produce. Physical output from Leontief coefficients, not value.
  {
    // 1a. Compute each capitalist's raw demand for workers (bounded by τ and money)
    const demands = [];
    for (const cap of capitalists) {
      const outputSym = cap.department === 1 ? '\u03C4' : '\u03C3';
      const tauAvail = cap.inventory['\u03C4'] || 0;
      const recipe = LEONTIEF_RECIPES.find(r => r.output === outputSym);
      if (!recipe || tauAvail < DEATH_THRESHOLD) { demands.push(0); continue; }
      const tauCoeff = recipe.coeffs[0];
      let maxScale = tauAvail / tauCoeff;
      // Also bound by affordable wages
      const affordable = Math.floor(cap.money / expandedParams.wagePerWorker);
      maxScale = Math.min(maxScale, affordable);
      demands.push(Math.max(0, Math.ceil(maxScale)));
    }
    const totalDemand = demands.reduce((s, d) => s + d, 0);
    const totalWorkers = workers.filter(w => !w.dead).length;

    // 1b. Allocate workers proportionally; shuffle to break ties fairly
    const shuffledWorkers = [...workers.filter(w => !w.dead)].sort(() => Math.random() - 0.5);
    const allocated = demands.map(() => []);
    if (totalDemand > 0 && totalWorkers > 0) {
      // Proportional with largest-remainder method
      const rawShares = demands.map(d => totalDemand > 0 ? d / totalDemand * totalWorkers : 0);
      const floors = rawShares.map(s => Math.floor(s));
      let remaining = totalWorkers - floors.reduce((s, f) => s + f, 0);
      // Sort by fractional part descending to distribute remainder
      const order = floors.map((_, i) => i).sort((a, b) => (rawShares[b] - floors[b]) - (rawShares[a] - floors[a]));
      for (const i of order) {
        if (remaining <= 0) break;
        if (demands[i] > 0) { floors[i]++; remaining--; }
      }
      let wIdx = 0;
      for (let ci = 0; ci < capitalists.length; ci++) {
        const n = Math.min(floors[ci], demands[ci]); // don't exceed demand
        allocated[ci] = shuffledWorkers.slice(wIdx, wIdx + n);
        wIdx += n;
      }
    }

    // 1c. Execute production for each capitalist with their allocated workers
    for (let ci = 0; ci < capitalists.length; ci++) {
      const cap = capitalists[ci];
      const hiredWorkers = allocated[ci];
      if (hiredWorkers.length === 0) continue;

      const deptKey = cap.department === 1 ? 'I' : 'II';
      const outputSym = cap.department === 1 ? '\u03C4' : '\u03C3';
      const tauAvail = cap.inventory['\u03C4'] || 0;
      const recipe = LEONTIEF_RECIPES.find(r => r.output === outputSym);
      if (!recipe || tauAvail < DEATH_THRESHOLD) continue;
      const tauCoeff = recipe.coeffs[0];

      // Scale bounded by τ and allocated labor
      let scale = Math.min(tauAvail / tauCoeff, hiredWorkers.length);
      const numHired = Math.min(hiredWorkers.length, Math.ceil(scale));

      // Check money for wages, scale down if needed
      const v = numHired * expandedParams.wagePerWorker;
      if (cap.money < v) {
        const affordable = Math.floor(cap.money / expandedParams.wagePerWorker);
        if (affordable === 0) continue;
        scale = Math.min(tauAvail / tauCoeff, affordable);
      }
      if (scale < DEATH_THRESHOLD) continue;

      const finalNumHired = Math.min(hiredWorkers.length, Math.ceil(scale));
      const finalTauConsumed = scale * tauCoeff;
      cap._tauConsumedThisTick = finalTauConsumed;
      const finalConstCap = finalTauConsumed * pTau;  // constant capital c valued at p(τ)
      const finalV = finalNumHired * expandedParams.wagePerWorker;
      const finalDelta = finalV * expandedParams.rateExploitation;  // surplus δ
      if (cap.money < finalV) continue;

      // Execute
      cap.removeGoods('\u03C4', finalTauConsumed);
      cap.money -= finalV;

      const wageEach = expandedParams.wagePerWorker;
      for (let wi = 0; wi < finalNumHired; wi++) {
        const w = hiredWorkers[wi];
        w.money += wageEach;
        w.wageIncome += wageEach;
        animations.push({type:'exchange_arrow', progress:0,
          from:{x:cap.x,y:cap.y}, to:{x:w.x,y:w.y},
          label:`m\u2098=${wageEach.toFixed(0)}`, color:'#3fb950'});
      }

      const outputQty = scale;
      cap.addGoods(outputSym, outputQty);
      cap.profitIncome += finalDelta;
      stepProducedQty += outputQty;
      productionCount++;

      deptAccounting[deptKey].c += finalConstCap;
      deptAccounting[deptKey].v += finalV;
      deptAccounting[deptKey].s += finalDelta;
      deptAccounting[deptKey].output += outputQty;

      animations.push({type:'production', x:cap.x, y:cap.y, progress:0});
      const outType = typeBySymbol(outputSym);
      animations.push({type:'produce_label', ownerId:cap.id, progress:0,
        label:`\u2191${outputQty.toFixed(1)}${outputSym}`, color:outType?.color||'#3fb950'});
      logEntry('production',`${cap.label} Dept ${deptKey}: ${finalTauConsumed.toFixed(1)}\u03C4 \u2192 ${outputQty.toFixed(1)}${outputSym}, c=${finalConstCap.toFixed(0)} v=${finalV.toFixed(0)} \u03B4=${finalDelta.toFixed(0)}`);
    }
  }

  // ── Phase 2: Worker Consumption (§21.3) ──
  // Workers buy σ at value-price p(σ)
  for (const w of workers) {
    if (w.money < DEATH_THRESHOLD) continue;
    const spendBudget = w.money * 0.9;
    // Find σ sellers (primarily Dept II capitalists)
    const sigmaSellers = alive.filter(p => (p.inventory['\u03C3'] || 0) > DEATH_THRESHOLD && p !== w);
    if (!sigmaSellers.length) continue;

    let spent = 0;
    for (const seller of sigmaSellers) {
      if (spent >= spendBudget) break;
      const avail = seller.inventory['\u03C3'] || 0;
      if (avail < DEATH_THRESHOLD) continue;
      const maxQty = Math.min(avail, (spendBudget - spent) / pSigma);
      if (maxQty < DEATH_THRESHOLD) continue;
      const price = maxQty * pSigma;
      seller.removeGoods('\u03C3', maxQty);
      w.money -= price;
      seller.money += price;
      spent += price;
      exchangeCount++;
      // Consume most of it (subsistence)
      const consumed = maxQty * 0.8;
      stepConsumedQty += consumed;
      // Worker keeps a small buffer
      w.addGoods('\u03C3', maxQty - consumed);
      logEntry('exchange',`${w.label} buys ${maxQty.toFixed(1)}\u03C3 from ${seller.label} @ ${price.toFixed(0)}`);
    }
  }

  // ── Phase 3: Allocation α^k (§22.1.4) ──
  // The allocation configuration: m'_n → r_n + c_{n+1} + v_{n+1}
  //   c_{n+1}: replacement of consumed τ + expansion (Leontief-proportional share of λ·δ)
  //   v_{n+1}: wages for next period (stays as money, spent in next tick's Phase 1)
  //   r_n = (1-λ)·δ: revenue, consumed privately
  // Inter-department exchange realizes the allocation:
  //   Dept II buys τ from Dept I (replacement + expansion)
  //   Dept I retains own τ (replacement + expansion implicit in inventory)
  //   Revenue: Dept II self-consumes σ; Dept I buys σ from Dept II
  const lambda = expandedParams.accumRate;
  const deptI_caps = capitalists.filter(c => c.department === 1);
  const deptII_caps = capitalists.filter(c => c.department === 2);

  // Helper: compute expansion τ for a capitalist using Leontief proportions
  // Reinvestment λ·δ buys additional scale; unit cost = tauCoeff·p(τ) + m_w
  // Additional τ = Δscale · tauCoeff
  function expansionTau(cap) {
    const delta = cap.profitIncome || 0;
    const outputSym = cap.department === 1 ? '\u03C4' : '\u03C3';
    const recipe = LEONTIEF_RECIPES.find(r => r.output === outputSym);
    const tauCoeff = recipe ? recipe.coeffs[0] : 0.5;
    const unitCost = tauCoeff * pTau + expandedParams.wagePerWorker;
    const deltaScale = (lambda * delta) / unitCost;
    return deltaScale * tauCoeff;
  }

  // 3a. Compute Dept I reserves: replacement + expansion (what they keep for next period)
  const deptI_reserves = new Map();
  for (const cap1 of deptI_caps) {
    const replacement = cap1._tauConsumedThisTick || 0;
    deptI_reserves.set(cap1, replacement + expansionTau(cap1));
  }

  // 3b. Dept II: buy τ from Dept I (replacement of consumed + expansion from λ·δ)
  for (const cap2 of deptII_caps) {
    const replacement = cap2._tauConsumedThisTick || 0;
    const expansion = expansionTau(cap2);
    const totalNeeded = replacement + expansion;
    const tauHave = cap2.inventory['\u03C4'] || 0;
    const tauToBuy = Math.max(0, totalNeeded - tauHave);

    if (tauToBuy > DEATH_THRESHOLD) {
      let bought = 0;
      for (const cap1 of deptI_caps) {
        if (bought >= tauToBuy) break;
        const reserve = deptI_reserves.get(cap1) || 0;
        const avail = Math.max(0, (cap1.inventory['\u03C4'] || 0) - reserve);
        if (avail < DEATH_THRESHOLD) continue;
        const qty = Math.min(avail, tauToBuy - bought, cap2.money / pTau);
        if (qty < DEATH_THRESHOLD) continue;
        const price = qty * pTau;
        cap1.removeGoods('\u03C4', qty);
        cap2.addGoods('\u03C4', qty);
        cap2.money -= price;
        cap1.money += price;
        bought += qty;
        exchangeCount++;
        const tag = expansion > DEATH_THRESHOLD
          ? `\u03B1\u1D4F: ${qty.toFixed(1)}\u03C4 (c\u2099\u208A\u2081=${replacement.toFixed(1)} + \u0394c=${expansion.toFixed(1)})`
          : `\u03B1\u1D4F: ${qty.toFixed(1)}\u03C4 (replacement c\u2099\u208A\u2081)`;
        logEntry('capital',`Dept II ${cap2.label} ${tag} from ${cap1.label}`);
        animations.push({type:'exchange_arrow', progress:0,
          from:{x:cap1.x,y:cap1.y}, to:{x:cap2.x,y:cap2.y},
          label:`${qty.toFixed(1)}\u03C4`, color:'#e06c75'});
      }
    }

    // Dept II revenue r = (1-λ)·δ: self-consume own σ
    const revenueAmt = (1 - lambda) * (cap2.profitIncome || 0);
    if (revenueAmt > DEATH_THRESHOLD) {
      const ownSigma = cap2.inventory['\u03C3'] || 0;
      const rQty = Math.min(ownSigma, revenueAmt / pSigma);
      if (rQty > DEATH_THRESHOLD) {
        cap2.removeGoods('\u03C3', rQty);
        stepConsumedQty += rQty;
        logEntry('exchange',`${cap2.label} revenue r: consumes ${rQty.toFixed(1)}\u03C3`);
      }
    }
  }

  // 3c. Dept I revenue r = (1-λ)·δ: buys σ from Dept II
  for (const cap1 of deptI_caps) {
    const rBudget = (cap1.profitIncome || 0) * (1 - lambda);
    if (rBudget < DEATH_THRESHOLD) continue;
    let spent = 0;
    for (const cap2 of deptII_caps) {
      if (spent >= rBudget) break;
      const avail = cap2.inventory['\u03C3'] || 0;
      if (avail < DEATH_THRESHOLD) continue;
      const maxQty = Math.min(avail, (rBudget - spent) / pSigma, cap1.money / pSigma);
      if (maxQty < DEATH_THRESHOLD) continue;
      const price = maxQty * pSigma;
      cap2.removeGoods('\u03C3', maxQty);
      cap1.money -= price;
      cap2.money += price;
      spent += price;
      stepConsumedQty += maxQty;
      exchangeCount++;
      logEntry('exchange',`Dept I ${cap1.label} revenue r: buys ${maxQty.toFixed(1)}\u03C3 from Dept II ${cap2.label}`);
      animations.push({type:'exchange_arrow', progress:0,
        from:{x:cap1.x,y:cap1.y}, to:{x:cap2.x,y:cap2.y},
        label:`${maxQty.toFixed(1)}\u03C3`, color:'#3fb950'});
    }
  }

  // ── Phase 5: Death check + Record history ──
  for (const p of alive) p.checkDeath();

  // Record to standard history arrays
  gHistory.push(proprietors.reduce((s,p)=>s+p.totalGoods(),0));
  const GV = proprietors.reduce((s,p)=>s+p.goodsValue(),0);
  vHistory.push(GV);
  const M = proprietors.reduce((s,p)=>s+p.money,0);
  mHistory.push(M);
  mevHistory.push(M > DEATH_THRESHOLD ? GV / M : 0);
  const melt = M > DEATH_THRESHOLD ? GV / M : 0;
  const meltAdjusted = proprietors.map(p => p.goodsValue() + p.money * melt);
  const totalMeltAdj = meltAdjusted.reduce((s,v) => s + v, 0);
  for (let i = 0; i < proprietors.length; i++){
    const share = totalMeltAdj > DEATH_THRESHOLD ? meltAdjusted[i] / totalMeltAdj * 100 : 0;
    ownerValueHistories[i].push(share);
  }
  prodPerTickHistory.push(stepProducedQty);
  consPerTickHistory.push(stepConsumedQty);
  // Push zeros to unused cumulative arrays for chart compat
  arbCumHistory.push(arbCumHistory.length ? arbCumHistory[arbCumHistory.length-1] : 0);
  surplusCumHistory.push(surplusCumHistory.length ? surplusCumHistory[surplusCumHistory.length-1] : 0);
  merchantCumHistory.push(merchantCumHistory.length ? merchantCumHistory[merchantCumHistory.length-1] : 0);
  usuryCumHistory.push(usuryCumHistory.length ? usuryCumHistory[usuryCumHistory.length-1] : 0);

  // Expanded-specific histories
  deptIOutputHistory.push(deptAccounting.I.output);
  deptIIOutputHistory.push(deptAccounting.II.output);
  const totalC = deptAccounting.I.c + deptAccounting.II.c;
  const totalV = deptAccounting.I.v + deptAccounting.II.v;
  const totalS = deptAccounting.I.s + deptAccounting.II.s;
  profitRateHistory.push((totalC + totalV) > DEATH_THRESHOLD ? totalS / (totalC + totalV) : 0);
  capitalStockHistory.push(proprietors.filter(p=>p.agentClass==='capitalist').reduce((s,p)=>s+(p.inventory['\u03C4']||0),0));
  organicCompHistory.push(totalV > DEATH_THRESHOLD ? totalC / totalV : 0);
  // κ = λε (§22.2.4) from actual accounting
  const actualEps = totalV > DEATH_THRESHOLD ? totalS / totalV : 0;
  kappaHistory.push(expandedParams.accumRate * actualEps);
  // Per-department profit rates
  const rI = (deptAccounting.I.c + deptAccounting.I.v) > DEATH_THRESHOLD
    ? deptAccounting.I.s / (deptAccounting.I.c + deptAccounting.I.v) : 0;
  const rII = (deptAccounting.II.c + deptAccounting.II.v) > DEATH_THRESHOLD
    ? deptAccounting.II.s / (deptAccounting.II.c + deptAccounting.II.v) : 0;
  profitRateIHistory.push(rI);
  profitRateIIHistory.push(rII);
  // Price deviation: expandedPrices / valuePrices
  const devTau = valuePrices['\u03C4'] > DEATH_THRESHOLD ? expandedPrices['\u03C4'] / valuePrices['\u03C4'] : 1;
  const devSig = valuePrices['\u03C3'] > DEATH_THRESHOLD ? expandedPrices['\u03C3'] / valuePrices['\u03C3'] : 1;
  priceDevTauHistory.push(devTau);
  priceDevSigHistory.push(devSig);
  // Normalized: divide by mean so redistribution is symmetric around 1.0
  const devMean = (devTau + devSig) / 2;
  normDevTauHistory.push(devMean > DEATH_THRESHOLD ? devTau / devMean : 1);
  normDevSigHistory.push(devMean > DEATH_THRESHOLD ? devSig / devMean : 1);

  recipeTimer = Math.max(0, recipeTimer-1);
  if (recipeTimer===0) document.getElementById('recipeToast').classList.remove('visible');
  updateStats();
}

// ── Simulation step ──
function step(){
  if (mode === 'expanded') { stepExpanded(); return; }
  // Check depletion — halt if G≈0
  const Gpre = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (Gpre<DEATH_THRESHOLD){
    if (playing){
      playing=false;
      document.getElementById('btn-play').innerHTML='\u25B6 Play';
      document.getElementById('btn-play').className='primary';
      logEntry('system','\u26A0 G\u22480 \u2014 circulation halted (depletion). \u00A79.10.4');
    }
    return;
  }

  tick++;
  stepConsumedQty = 0;
  stepProducedQty = 0;
  stepArbQty = 0;
  stepSurplusQty = 0;
  stepMerchantProfit = 0;
  stepLoanInterest = 0;
  const alive = proprietors.filter(p=>!p.dead);
  const shuffled = [...alive].sort(()=>Math.random()-0.5);

  if (coupleExchangeConsumption) {
    // ═══════════════════════════════════════════════════════════
    // COUPLED: Exchange first (drives consumption), then production matches
    // ═══════════════════════════════════════════════════════════

    // Stabilizer: adjust consumption probability based on |G| drift
    const drift = Gpre - targetG;
    currentConsRate = Math.min(0.85, Math.max(0.15, 0.5 + drift*0.02));

    // 1. Exchanges (probabilistic consumption → stepConsumedQty tracked)
    runExchanges(shuffled);

    // 2. Production: match consumption (or exceed it under industrial capital).
    //    Each production event nets scale*(1-colSum) units.
    if (prodMode!=='off' && stepConsumedQty>DEATH_THRESHOLD){
      let netProduced = 0;
      // Industrial capital: surplus production beyond replacement
      const target = capitalSubModes.industrial
        ? stepConsumedQty * 2.0
        : stepConsumedQty;
      // Sort by ascending goods — poorest produce first
      const prodOrder = [...shuffled].sort((a,b) => a.totalGoods() - b.totalGoods());
      for (const p of prodOrder){
        if (netProduced>=target) break;
        // Industrial surplus production: only eligible owners produce beyond replacement
        if (capitalSubModes.industrial && netProduced >= stepConsumedQty && !capitalEligible.industrial.has(p.id)) continue;
        const remaining = target - netProduced;
        const goodsBefore = p.totalGoods();
        if (attemptLeontief(p, remaining)) {
          netProduced += p.totalGoods() - goodsBefore;
        }
      }
    }

  } else {
    // ═══════════════════════════════════════════════════════════
    // INDEPENDENT: Production+Consumption first, then exchanges
    // ═══════════════════════════════════════════════════════════
    if (prodMode==='off'){
      consumeGoods(alive, 0.07);
    } else {
      // ── LEONTIEF STABILIZER (§9.12–9.14) ──
      const drift = Gpre - targetG;
      const consRate = Math.min(0.12, Math.max(0, 0.055 + drift*0.015));
      const prodRate = Math.min(0.12, Math.max(0, 0.055 - drift*0.015));
      currentConsRate = consRate;
      for (const p of shuffled){
        if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<prodRate)
          attemptLeontief(p);
      }
      consumeGoods(alive, consRate);
    }
    runExchanges(shuffled);
  }

  // ── Death check ──
  for (const p of alive) p.checkDeath();

  // Record
  gHistory.push(proprietors.reduce((s,p)=>s+p.totalGoods(),0));
  const GV = proprietors.reduce((s,p)=>s+p.goodsValue(),0); // goods-only value
  vHistory.push(GV);
  const M = proprietors.reduce((s,p)=>s+p.money,0);
  mHistory.push(M);
  mevHistory.push(M > DEATH_THRESHOLD ? GV / M : 0); // MELT: value per unit of money
  // MELT-adjusted value share: goodsValue + money × MELT
  const melt = M > DEATH_THRESHOLD ? GV / M : 0;
  const meltAdjusted = proprietors.map(p => p.goodsValue() + p.money * melt);
  const totalMeltAdj = meltAdjusted.reduce((s,v) => s + v, 0);
  for (let i = 0; i < proprietors.length; i++){
    const share = totalMeltAdj > DEATH_THRESHOLD ? meltAdjusted[i] / totalMeltAdj * 100 : 0;
    ownerValueHistories[i].push(share);
  }
  prodPerTickHistory.push(stepProducedQty);
  consPerTickHistory.push(stepConsumedQty);
  arbCumHistory.push((arbCumHistory.length ? arbCumHistory[arbCumHistory.length-1] : 0) + stepArbQty);
  surplusCumHistory.push((surplusCumHistory.length ? surplusCumHistory[surplusCumHistory.length-1] : 0) + stepSurplusQty);
  merchantCumHistory.push((merchantCumHistory.length ? merchantCumHistory[merchantCumHistory.length-1] : 0) + stepMerchantProfit);
  usuryCumHistory.push((usuryCumHistory.length ? usuryCumHistory[usuryCumHistory.length-1] : 0) + stepLoanInterest);
  recipeTimer = Math.max(0, recipeTimer-1);
  if (recipeTimer===0) document.getElementById('recipeToast').classList.remove('visible');
  updateStats();
}

// ── Gini coefficient (0 = perfect equality, 1 = total concentration) ──
function computeGini(values){
  const n = values.length;
  if (n < 2) return 0;
  const sorted = [...values].sort((a, b) => a - b);
  const sum = sorted.reduce((s, v) => s + v, 0);
  if (sum < DEATH_THRESHOLD) return 0;
  let numerator = 0;
  for (let i = 0; i < n; i++){
    numerator += (2 * (i + 1) - n - 1) * sorted[i];
  }
  return numerator / (n * sum);
}

// ── Consumption helper ──
function consumeGoods(props, rate){
  for (const p of props){
    if (p.totalGoods()>DEATH_THRESHOLD && Math.random()<rate){
      const sym = p.randomGoodType();
      if (!sym) continue;
      const qty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        p.inventory[sym] || 0
      );
      if (qty < DEATH_THRESHOLD) continue;
      p.removeGoods(sym, qty);
      logEntry('depletion',`${p.label} consumed ${qty.toFixed(2)} ${sym}`);
      stepConsumedQty += qty;
    }
  }
}

function attemptBuy(buyer){
  if (buyer.dead) return;
  const sellers = proprietors.filter(p=>p!==buyer && !p.dead && p.totalGoods()>DEATH_THRESHOLD);
  if (!sellers.length) return;
  const seller = sellers[Math.floor(Math.random()*sellers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  // Random exchange quantity, capped by seller's available and buyer's money
  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  qty = Math.min(qty, buyer.money / UNIT_PRICE);
  if (qty < DEATH_THRESHOLD) return;
  const price = qty * UNIT_PRICE;

  seller.removeGoods(sym, qty);
  buyer.addGoods(sym, qty);
  buyer.money -= price;
  seller.money += price;
  buyer.role='buyer'; buyer.roleTimer=6;
  seller.role='seller'; seller.roleTimer=6;
  exchangeCount++;

  addExchangeAnim(buyer, seller, sym, qty, price);
  logEntry('exchange',`${seller.label} \u2194 ${buyer.label}: ${qty.toFixed(2)} ${sym} @ ${price.toFixed(1)}`);

  // Coupled consumption: buying triggers consuming a fraction of buyer's goods
  if (coupleExchangeConsumption && Math.random()<currentConsRate && buyer.totalGoods()>DEATH_THRESHOLD) {
    const csym = buyer.randomGoodType();
    if (csym) {
      const cqty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        buyer.inventory[csym] || 0
      );
      if (cqty > DEATH_THRESHOLD) {
        buyer.removeGoods(csym, cqty);
        logEntry('depletion',`${buyer.label} consumed ${cqty.toFixed(2)} ${csym}`);
        stepConsumedQty += cqty;
      }
    }
  }
}

function attemptSell(seller){
  if (seller.dead) return;
  const buyers = proprietors.filter(p=>p!==seller && !p.dead && p.money>0);
  if (!buyers.length) return;
  const buyer = buyers[Math.floor(Math.random()*buyers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  // Random exchange quantity, capped by seller's available and buyer's money
  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  qty = Math.min(qty, buyer.money / UNIT_PRICE);
  if (qty < DEATH_THRESHOLD) return;
  const price = qty * UNIT_PRICE;

  seller.removeGoods(sym, qty);
  buyer.addGoods(sym, qty);
  buyer.money -= price;
  seller.money += price;
  buyer.role='buyer'; buyer.roleTimer=6;
  seller.role='seller'; seller.roleTimer=6;
  exchangeCount++;

  addExchangeAnim(buyer, seller, sym, qty, price);
  logEntry('exchange',`${seller.label} \u2194 ${buyer.label}: ${qty.toFixed(2)} ${sym} @ ${price.toFixed(1)}`);

  // Coupled consumption: buying triggers consuming a fraction of buyer's goods
  if (coupleExchangeConsumption && Math.random()<currentConsRate && buyer.totalGoods()>DEATH_THRESHOLD) {
    const csym = buyer.randomGoodType();
    if (csym) {
      const cqty = Math.min(
        CONSUME_QTY_MIN + Math.random()*(CONSUME_QTY_MAX - CONSUME_QTY_MIN),
        buyer.inventory[csym] || 0
      );
      if (cqty > DEATH_THRESHOLD) {
        buyer.removeGoods(csym, cqty);
        logEntry('depletion',`${buyer.label} consumed ${cqty.toFixed(2)} ${csym}`);
        stepConsumedQty += cqty;
      }
    }
  }
}

// ── Leontief production (continuous) ──
// Try all recipes (weighted-shuffled) until one matches inputs. Returns boolean.
// Produces scale units of output consuming scale*coeff_i of each input.
// Net change to |G|: scale*(1-colSum) > 0 (labor's contribution).
// maxNetQty: if provided, cap scale so net output doesn't exceed this.
function attemptLeontief(producer, maxNetQty){
  if (producer.dead) return false;

  // Try recipes in weighted-shuffled order (biased toward equilibrium)
  const indices = Array.from({length:N_SECTORS}, (_,i)=>i);
  indices.sort((a,b)=>(Math.random()/(PROD_WEIGHTS[a]||0.01))-(Math.random()/(PROD_WEIGHTS[b]||0.01)));

  let chosen = null, maxScale = 0;
  for (const k of indices){
    const recipe = LEONTIEF_RECIPES[k];
    if (!recipe) continue;
    // Aggregate required amounts per input type (handles duplicate inputs)
    const required = {};
    for (let i = 0; i < recipe.inputs.length; i++){
      required[recipe.inputs[i]] = (required[recipe.inputs[i]] || 0) + recipe.coeffs[i];
    }
    // Compute max scale = min(available / totalCoeff) across input types
    let minRatio = Infinity;
    let canDo = true;
    for (const [sym, totalCoeff] of Object.entries(required)){
      const avail = producer.inventory[sym] || 0;
      if (avail < DEATH_THRESHOLD){ canDo=false; break; }
      minRatio = Math.min(minRatio, avail / totalCoeff);
    }
    if (!canDo || minRatio < DEATH_THRESHOLD) continue;
    chosen = recipe;
    maxScale = Math.min(minRatio, PROD_SCALE_MAX);
    break;
  }
  if (!chosen || maxScale < DEATH_THRESHOLD) return false;

  const colSum = chosen.coeffs.reduce((s, c) => s + c, 0);

  // Cap scale so net production (scale*(1-colSum)) doesn't overshoot budget
  let scale = maxScale;
  if (maxNetQty !== undefined) {
    const netPerUnit = 1 - colSum;
    if (netPerUnit > DEATH_THRESHOLD) {
      scale = Math.min(scale, maxNetQty / netPerUnit);
    }
  }
  if (scale < DEATH_THRESHOLD) return false;

  // Consume inputs
  const inputQtys = {};
  const required = {};
  for (let i = 0; i < chosen.inputs.length; i++){
    required[chosen.inputs[i]] = (required[chosen.inputs[i]] || 0) + chosen.coeffs[i];
  }
  for (const [sym, totalCoeff] of Object.entries(required)){
    const qty = scale * totalCoeff;
    producer.removeGoods(sym, qty);
    inputQtys[sym] = qty;
  }

  // Produce output
  const outSym = chosen.output;
  producer.addGoods(outSym, scale);
  stepProducedQty += scale;

  // Value accounting
  const inputValue = scale * colSum * UNIT_PRICE;
  const outputValue = scale * UNIT_PRICE;
  const laborValue = outputValue - inputValue; // = scale * (1-colSum) * UNIT_PRICE

  // ── Labor value split ──
  const fullLaborValue = laborValue;
  let tr = 0, surplus = 0, laborer = null;
  if (laborMode === 'commodity' && fullLaborValue > 0) {
    tr = Math.max(0.01, fullLaborValue * trRatio);
    surplus = fullLaborValue - tr;
    if (producer.money < tr) {
      // Undo: restore inputs, remove output
      for (const [sym, qty] of Object.entries(inputQtys)){
        producer.addGoods(sym, qty);
      }
      producer.removeGoods(outSym, scale);
      return false;
    }
    const laborers = proprietors.filter(p => p !== producer && !p.dead);
    if (laborers.length > 0) {
      laborer = laborers[Math.floor(Math.random() * laborers.length)];
      producer.money -= tr;
      laborer.money += tr;
    }
    surplusLabor += surplus;
    stepSurplusQty += surplus;
    if (laborer) {
      animations.push({type:'exchange_arrow', progress:0,
        from:{x:producer.x,y:producer.y}, to:{x:laborer.x,y:laborer.y},
        label:`t\u1D63=${tr.toFixed(1)}`, color:'#3fb950'});
    }
  }

  producer.role='producer'; producer.roleTimer=8;
  productionCount++;

  // Animations
  const outType = typeBySymbol(outSym);
  animations.push({type:'production', x:producer.x, y:producer.y, progress:0});
  const inputsDown = Object.entries(inputQtys).map(([s,q])=>`\u2193${q.toFixed(1)}${s}`).join(' ');
  const laborDown = laborMode==='commodity' && laborer ? ` \u2193t\u1D63=${tr.toFixed(1)}` : '';
  animations.push({type:'produce_label', ownerId:producer.id, progress:0,
    label:`\u2191${scale.toFixed(1)}${outSym}  ${inputsDown}${laborDown}`, color:outType?.color||'#3fb950'});

  const inStr  = Object.entries(inputQtys).map(([s,q])=>`${q.toFixed(2)}${s}`).join('+');
  const laborStr = laborMode==='commodity' && laborer
    ? `t=${fullLaborValue.toFixed(1)}, t\u1D63=${tr.toFixed(1)}\u2192${laborer.label}, t\u209B=${surplus.toFixed(1)}`
    : `t=${fullLaborValue.toFixed(1)}`;
  const rLabel = recipeLabel(chosen);
  logEntry('production',`${producer.label}: ${inStr} \u2192 ${scale.toFixed(2)} ${outSym}  ${laborStr}  [${rLabel}]`);

  // Recipe toast — position near the producer
  const toast = document.getElementById('recipeToast');
  toast.innerHTML = `${producer.label} &nbsp;${rLabel} &nbsp; ${inStr}\u2192${scale.toFixed(2)}${outSym}<br>${laborStr}`;
  const cxCanvas = canvas.width/(2*DPR), cyCanvas = canvas.height/(2*DPR);
  const nodeR = Math.min(52, Math.min(cxCanvas,cyCanvas)*0.73*0.34);
  toast.style.left = producer.x + 'px';
  toast.style.top = (producer.y + nodeR + 36) + 'px';
  toast.classList.add('visible');
  recipeTimer = 20;
  return true;
}

function attemptCapital(cap){
  if (cap.dead) return;
  if (cap.money<5) return;

  // M→C: buy fraction of a good from seller
  const sellers = proprietors.filter(p=>p!==cap && !p.dead && p.totalGoods()>DEATH_THRESHOLD);
  if (!sellers.length) return;
  const seller = sellers[Math.floor(Math.random()*sellers.length)];
  const sym = seller.randomGoodType();
  if (!sym) return;

  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  const m1 = qty * UNIT_PRICE;
  if (cap.money < m1 || qty < DEATH_THRESHOLD) return;

  // C→M': find a buyer willing to pay markup (layer-divergent operation §11.3)
  const markup = Math.max(0.5, m1 * 0.2);
  const m2 = m1 + markup;
  const buyers = proprietors.filter(p=>p!==cap && p!==seller && !p.dead && p.money>=m2);
  if (!buyers.length) return; // no buyer at markup → no capital circuit

  const buyer = buyers[Math.floor(Math.random()*buyers.length)];

  // Execute M→C→M': commodity passes through, money redistributed
  cap.money -= m1;            // capitalist pays seller
  seller.money += m1;
  seller.removeGoods(sym, qty);
  buyer.money -= m2;           // buyer pays capitalist at markup
  cap.money += m2;
  buyer.addGoods(sym, qty);   // commodity reaches final buyer (stays in G!)

  const surp = m2 - m1;    // δ = M' − M
  cap.capitalSurplus += surp;
  surplusAccumulated += surp;
  stepArbQty += surp;

  cap.role='capitalist'; cap.roleTimer=12;
  seller.role='seller'; seller.roleTimer=6;
  buyer.role='buyer'; buyer.roleTimer=6;
  exchangeCount += 2; // two exchanges in the circuit

  // Animations: seller → cap → buyer
  animations.push({type:'capital', from:{x:seller.x,y:seller.y}, to:{x:cap.x,y:cap.y}, progress:0});
  animations.push({type:'capital', from:{x:cap.x,y:cap.y}, to:{x:buyer.x,y:buyer.y}, progress:0});
  logEntry('capital',`${cap.label}: M(${m1.toFixed(1)})\u2192C(${qty.toFixed(2)} ${sym})\u2192M'(${m2.toFixed(1)}), \u03B4=${surp.toFixed(1)}  [${seller.label}\u2192${cap.label}\u2192${buyer.label}]`);
}

// ── Merchant Capital ──
function attemptMerchantCapital(merchant){
  if (merchant.dead) return;
  if (merchant.money < 5) return;

  // Buy a domestic good from a seller
  const sellers = proprietors.filter(p=>p!==merchant && !p.dead && p.totalGoods()>DEATH_THRESHOLD);
  if (!sellers.length) return;
  const seller = sellers[Math.floor(Math.random()*sellers.length)];
  const sym = seller.randomGoodType();
  if (!sym || sym === FOREIGN_GOOD.sym) return; // don't re-trade foreign goods

  let qty = EXCHANGE_QTY_MIN + Math.random()*(EXCHANGE_QTY_MAX - EXCHANGE_QTY_MIN);
  qty = Math.min(qty, seller.inventory[sym] || 0);
  const cost = qty * UNIT_PRICE;
  if (merchant.money < cost || qty < DEATH_THRESHOLD) return;

  // Value asymmetry: 1 unit domestic trades 1:1 for 1 unit Sp abroad,
  // but Sp is valued higher domestically (value multiplier > 1)
  const valueRate = merchantExchangeRates[sym] || 1.5;
  const foreignQty = qty; // 1:1 quantity exchange
  const foreignValue = foreignQty * UNIT_PRICE * valueRate; // Sp sells at higher value

  const buyers = proprietors.filter(p=>p!==merchant && p!==seller && !p.dead && p.money>=foreignValue);
  if (!buyers.length) return;
  const buyer = buyers[Math.floor(Math.random()*buyers.length)];

  // Execute: merchant buys domestic, trades abroad 1:1 for Sp, sells Sp at higher value
  merchant.money -= cost;
  seller.money += cost;
  seller.removeGoods(sym, qty);

  buyer.money -= foreignValue;
  merchant.money += foreignValue;
  buyer.addGoods(FOREIGN_GOOD.sym, foreignQty);

  const profit = foreignValue - cost; // = qty * UNIT_PRICE * (valueRate - 1)
  stepMerchantProfit += profit;
  surplusAccumulated += profit;

  merchant.role='capitalist'; merchant.roleTimer=12;
  seller.role='seller'; seller.roleTimer=6;
  buyer.role='buyer'; buyer.roleTimer=6;
  exchangeCount += 2;

  // Ship sails in from center (abroad) to merchant, then merchant delivers to buyer
  const cxAnim = canvas.width/(2*DPR), cyAnim = canvas.height/(2*DPR);
  animations.push({type:'merchant', from:{x:cxAnim,y:cyAnim}, to:{x:merchant.x,y:merchant.y}, progress:0, label:`${foreignQty.toFixed(1)}Sp`});
  animations.push({type:'exchange_arrow', from:{x:merchant.x,y:merchant.y}, to:{x:buyer.x,y:buyer.y}, progress:0, color:FOREIGN_GOOD.color, label:`${foreignQty.toFixed(1)}Sp`});
  logEntry('capital',`\uD83C\uDFEA ${merchant.label}: merchant ${qty.toFixed(2)}${sym}\u2192${foreignQty.toFixed(2)}Sp @${valueRate.toFixed(1)}\u00D7, profit=${profit.toFixed(1)} [${seller.label}\u2192${buyer.label}]`);
}

// ── Usury Capital ──
function attemptUsury(lender){
  if (lender.dead || lender.money < 15) return;

  // Find a cash-poor proprietor with goods (has collateral but no money)
  const candidates = proprietors.filter(p =>
    p !== lender && !p.dead && p.money < 5 && p.totalGoods() > DEATH_THRESHOLD
    && !loans.some(l => l.lenderId === lender.id && l.borrowerId === p.id)
  );
  if (!candidates.length) return;
  const borrower = candidates[Math.floor(Math.random()*candidates.length)];

  const principal = Math.min(lender.money * 0.3, 10);
  if (principal < 1) return;
  const remaining = principal * (1 + usuryInterestRate);

  lender.money -= principal;
  borrower.money += principal;

  loans.push({
    lenderId: lender.id,
    borrowerId: borrower.id,
    principal: principal,
    remaining: remaining,
    interestRate: usuryInterestRate
  });

  lender.role='capitalist'; lender.roleTimer=10;
  borrower.role='buyer'; borrower.roleTimer=6;

  logEntry('capital',`\uD83D\uDCB0 ${lender.label} lends ${principal.toFixed(1)} to ${borrower.label} (repay ${remaining.toFixed(1)}, rate=${(usuryInterestRate*100).toFixed(0)}%)`);
}

function processLoanRepayments(){
  for (let i = loans.length - 1; i >= 0; i--){
    const loan = loans[i];
    const debtor = proprietors.find(p => p.id === loan.borrowerId);
    const lender = proprietors.find(p => p.id === loan.lenderId);

    // Write off if debtor is dead
    if (!debtor || debtor.dead){
      loans.splice(i, 1);
      continue;
    }

    // Pay installment (slower at higher sim speed so loans are visible longer)
    const simSpd = +document.getElementById('speed').value;
    const spdFactor = Math.max(0.15, 1 / simSpd);
    const payment = Math.min(debtor.money * usuryInstallmentRatio * spdFactor, loan.remaining);
    if (payment > DEATH_THRESHOLD && debtor.money >= payment){
      debtor.money -= payment;
      if (lender && !lender.dead) lender.money += payment;
      const interest = payment * (loan.interestRate / (1 + loan.interestRate));
      stepLoanInterest += interest;
      loan.remaining -= payment;
    }

    // Retire loan if paid off
    if (loan.remaining <= DEATH_THRESHOLD){
      loans.splice(i, 1);
      logEntry('capital',`\u2705 Loan ${lender?lender.label:'?'}\u2192${debtor.label} repaid`);
    }
  }
}

// ── Capital sub-mode toggles ──
function setMerchantCapital(on){
  capitalSubModes.merchant = on;
  if (on) proprietors.filter(p=>!p.dead).forEach(p => capitalEligible.merchant.add(p.id));
  document.getElementById('btn-merchant-on').className = on?'active':'';
  document.getElementById('btn-merchant-off').className = on?'':'active';
  document.getElementById('merchant-rates-container').style.display = on?'block':'none';
  if (on) renderMerchantRates();
  updateCapitalSubmodesDesc();
  renderCapitalOwnerPickers();
  markPresetDirty();
}

function setUsuryCapital(on){
  capitalSubModes.usury = on;
  if (on) proprietors.filter(p=>!p.dead).forEach(p => capitalEligible.usury.add(p.id));
  document.getElementById('btn-usury-on').className = on?'active':'';
  document.getElementById('btn-usury-off').className = on?'':'active';
  document.getElementById('usury-settings').style.display = on?'block':'none';
  updateCapitalSubmodesDesc();
  renderCapitalOwnerPickers();
  markPresetDirty();
}

function setIndustrialCapital(on){
  capitalSubModes.industrial = on;
  if (on) proprietors.filter(p=>!p.dead).forEach(p => capitalEligible.industrial.add(p.id));
  document.getElementById('btn-industrial-on').className = on?'active':'';
  document.getElementById('btn-industrial-off').className = on?'':'active';
  if (on){
    setLabor('commodity');
    document.getElementById('btn-labor-implicit').disabled = true;
    document.getElementById('btn-labor-implicit').style.opacity = '0.4';
  } else {
    document.getElementById('btn-labor-implicit').disabled = false;
    document.getElementById('btn-labor-implicit').style.opacity = '1';
  }
  updateCapitalSubmodesDesc();
  renderCapitalOwnerPickers();
  markPresetDirty();
}

function renderMerchantRates(){
  const el = document.getElementById('merchant-rates-table');
  if (!el) return;
  let html = '';
  for (const t of TYPES){
    const rate = merchantExchangeRates[t.sym] || 1.5;
    html += `<div class="tech-edit-row">
      <span class="tech-edit-sym" style="color:${t.color}">${t.sym}</span>
      <span class="tech-edit-arrow">\u2192</span>
      <span style="color:#ff9f43;font-size:12px;">Sp</span>
      <span style="color:#6e7681;font-size:12px;margin:0 4px;">\u00D7</span>
      <input type="number" min="1.0" max="5.0" step="0.1" value="${rate.toFixed(1)}"
             onchange="onMerchantRateChange('${t.sym}',this.value)"
             style="width:70px;" title="Sp value multiplier vs ${t.sym}">
      <span style="color:#6e7681;font-size:11px;">value</span>
    </div>`;
  }
  el.innerHTML = html;
}

function onMerchantRateChange(sym, val){
  merchantExchangeRates[sym] = Math.max(1.0, Math.min(5.0, parseFloat(val) || 1.5));
  markPresetDirty();
}

function updateUsuryRate(){
  const slider = document.getElementById('usuryRateSlider');
  usuryInterestRate = +slider.value / 100;
  document.getElementById('usury-rate-pct').textContent = slider.value;
  markPresetDirty();
}

function updateUsuryInstallment(){
  const slider = document.getElementById('usuryInstallSlider');
  usuryInstallmentRatio = +slider.value / 100;
  document.getElementById('usury-install-pct').textContent = slider.value;
  markPresetDirty();
}

function renderCapitalOwnerPickers(){
  ['merchant','usury','industrial'].forEach(sm => {
    const el = document.getElementById(sm+'-owners');
    if (!el) return;
    const alive = proprietors.filter(p => !p.dead);
    const isOn = capitalSubModes[sm];
    const set = capitalEligible[sm];
    const allOn = isOn && alive.every(p => set.has(p.id));
    const dis = isOn ? '' : 'disabled';
    const opac = isOn ? '' : 'opacity:0.4;';
    let html = '<div class="group-label" style="font-size:12px;margin-bottom:4px;">Owners</div>';
    html += `<div style="display:flex;flex-wrap:wrap;gap:6px;align-items:center;${opac}">`;
    html += `<label style="font-size:12px;cursor:${isOn?'pointer':'default'};margin-right:4px;color:#8b949e;">`;
    html += `<input type="checkbox" ${allOn?'checked':''} ${dis} onchange="toggleAllCapitalOwners('${sm}',this.checked)" style="margin-right:2px;">All</label>`;
    for (const p of alive) {
      const checked = isOn && set.has(p.id) ? 'checked' : '';
      html += `<label style="font-size:12px;cursor:${isOn?'pointer':'default'};">`;
      html += `<input type="checkbox" ${checked} ${dis} onchange="toggleCapitalOwner('${sm}',${p.id},this.checked)" style="margin-right:2px;">${p.label}</label>`;
    }
    html += '</div>';
    el.innerHTML = html;
  });
}

function toggleCapitalOwner(md, ownerId, on){
  if (on) capitalEligible[md].add(ownerId);
  else capitalEligible[md].delete(ownerId);
  renderCapitalOwnerPickers();
  markPresetDirty();
}

function toggleAllCapitalOwners(md, on){
  if (on) proprietors.filter(p=>!p.dead).forEach(p => capitalEligible[md].add(p.id));
  else capitalEligible[md].clear();
  renderCapitalOwnerPickers();
  markPresetDirty();
}

function openCapitalModal(){
  renderMerchantRates();
  renderCapitalOwnerPickers();
  document.getElementById('capitalModal').classList.remove('hidden');
}
function closeCapitalModal(){
  document.getElementById('capitalModal').classList.add('hidden');
}

function updateCapitalSubmodesDesc(){
  const active = [];
  if (capitalSubModes.merchant) active.push('Merchant');
  if (capitalSubModes.usury) active.push('Usury');
  if (capitalSubModes.industrial) active.push('Industrial');
  const el = document.getElementById('capital-forms-desc');
  if (el) el.textContent = active.length ? 'Active: ' + active.join(', ') : 'No sub-modes active.';
}

// ── Animations ──
function addExchangeAnim(buyer, seller, sym, qty, price){
  const ctype = typeBySymbol(sym);
  // Arrows without labels
  animations.push({type:'exchange_arrow', from:{x:buyer.x,y:buyer.y}, to:{x:seller.x,y:seller.y}, progress:0,
    color:'#58a6ff'});
  animations.push({type:'exchange_arrow', from:{x:seller.x,y:seller.y}, to:{x:buyer.x,y:buyer.y}, progress:0,
    color:ctype?.color||'#f0883e'});
  // Receipts: what each party gained/lost
  animations.push({type:'produce_label', ownerId:buyer.id, progress:0,
    label:`\u2191${qty.toFixed(1)}${sym} \u2193m=${price.toFixed(1)}`, color:'#79c0ff'});
  animations.push({type:'produce_label', ownerId:seller.id, progress:0,
    label:`\u2191m=${price.toFixed(1)} \u2193${qty.toFixed(1)}${sym}`, color:'#f0883e'});
}

// ── Render ──
function resize(){
  const cw = canvas.parentElement;
  canvas.width  = cw.clientWidth * DPR;
  canvas.height = cw.clientHeight * DPR;
  canvas.style.width  = cw.clientWidth + 'px';
  canvas.style.height = cw.clientHeight + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);

  const cc = chartCanvas.parentElement;
  chartCanvas.width  = cc.clientWidth * DPR;
  chartCanvas.height = cc.clientHeight * DPR;
  chartCanvas.style.width  = cc.clientWidth + 'px';
  chartCanvas.style.height = cc.clientHeight + 'px';
  chartCtx.setTransform(DPR,0,0,DPR,0,0);

  if (proprietors.length){
    const cx = canvas.width/(2*DPR);
    const cy = canvas.height/(2*DPR);
    const r  = Math.min(cx,cy)*0.73;
    const n  = proprietors.length;
    for (let i=0;i<n;i++){
      const a = 2*Math.PI*i/n - Math.PI/2;
      proprietors[i].x = cx+r*Math.cos(a);
      proprietors[i].y = cy+r*Math.sin(a);
    }
  }
}

function draw(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  ctx.clearRect(0,0,W,H);
  const cx = W/2, cy = H/2;
  const radius = Math.min(cx,cy)*0.73;

  // Circulation ring
  ctx.beginPath(); ctx.arc(cx,cy,radius,0,2*Math.PI);
  ctx.strokeStyle='#30363d'; ctx.lineWidth=2; ctx.stroke();

  // Center label
  ctx.textAlign='center'; ctx.textBaseline='middle';
  if (mode==='cc'){
    ctx.font='26px Georgia'; ctx.fillStyle='#c6cdd5';
    ctx.fillText('Circulation \u00A79', cx, cy-20);
    ctx.font='italic 33px Georgia'; ctx.fillStyle='#8b949eaa';
    ctx.fillText('C \u2192 M \u2192 C\u2032', cx, cy+20);
  } else if (mode==='expanded'){
    ctx.font='26px Georgia'; ctx.fillStyle='#ffa060';
    ctx.fillText('Reproduction \u00A722', cx, cy-36);
    ctx.font='italic 20px Georgia'; ctx.fillStyle='#ffa060bb';
    ctx.fillText('m \u2192 C \u2192 \u03A0(\u2113,\u03C4) \u2192 C\u2032 \u2192 m\u2032', cx, cy-8);
    ctx.font='18px Georgia'; ctx.fillStyle='#ffa060aa';
    ctx.fillText('Dept I (\u03C4)  \u00B7  Dept II (\u03C3)', cx, cy+16);
    ctx.font='14px "SF Mono",Consolas,monospace'; ctx.fillStyle='#ffa06088';
    const kappa = expandedParams.accumRate * expandedParams.rateExploitation;
    ctx.fillText(`\u03BB=${Math.round(expandedParams.accumRate*100)}%  \u03B5=${Math.round(expandedParams.rateExploitation*100)}%  \u03BA=${Math.round(kappa*100)}%`, cx, cy+38);
  } else {
    ctx.font='26px Georgia'; ctx.fillStyle='#bfa0d4';
    ctx.fillText('Capital \u00A711\u201315', cx, cy-20);
    ctx.font='italic 33px Georgia'; ctx.fillStyle='#bfa0d4aa';
    ctx.fillText('M \u2192 C \u2192 \u2026 \u2192 M\u2032', cx, cy+20);
  }

  // Usury: draw dashed gold lines for active loans
  if (capitalSubModes.usury) {
    for (const loan of loans){
      const lender = proprietors.find(p=>p.id===loan.lenderId);
      const borrower = proprietors.find(p=>p.id===loan.borrowerId);
      if (!lender || !borrower || lender.dead || borrower.dead) continue;
      ctx.save();
      // Width proportional to remaining debt (thick when new, thins as repaid)
      const debtRatio = loan.remaining / (loan.principal * (1 + loan.interestRate));
      const lw = 2 + debtRatio * 22; // 24px at full debt → 2px near payoff
      ctx.beginPath();
      ctx.moveTo(lender.x, lender.y);
      ctx.lineTo(borrower.x, borrower.y);
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = lw;
      ctx.globalAlpha = 0.3 + debtRatio * 0.4;
      ctx.stroke();
      // Debt label at midpoint
      const mx = (lender.x + borrower.x) / 2;
      const my = (lender.y + borrower.y) / 2;
      ctx.globalAlpha = 0.8;
      ctx.font = '11px "SF Mono",Consolas,monospace';
      ctx.fillStyle = '#ffd700';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(`debt=${loan.remaining.toFixed(1)}`, mx, my - 8);
      ctx.restore();
    }
  }

  // Animations
  for (let i=animations.length-1;i>=0;i--){
    const a=animations[i];
    // Exchange arrows: fade time correlates with sim speed, minimum 1 second
    const simSpd = +document.getElementById('speed').value;
    const fadeMs = Math.max(1000, 3000/simSpd);
    const exchFade = 1/(fadeMs/1000*60);
    const spd = (a.type==='produce_label') ? 0.015
              : (a.type==='merchant') ? 0.005
              : (a.type==='exchange_arrow') ? exchFade
              : 0.025;
    a.progress += spd;
    if (a.progress>=1){ animations.splice(i,1); continue; }
    const t=a.progress;
    const fade = Math.floor((1-t)*255).toString(16).padStart(2,'0');

    if (a.type==='exchange_arrow'){
      // Draw a transparent arrow with white border from source → target
      const nodeR = Math.min(52, radius*0.34);
      const dx=a.to.x-a.from.x, dy=a.to.y-a.from.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if (dist<1) continue;
      const ux=dx/dist, uy=dy/dist; // unit vector
      // Start/end inset from node edges
      const sx=a.from.x+ux*(nodeR+14), sy=a.from.y+uy*(nodeR+14);
      const ex=a.to.x-ux*(nodeR+14),   ey=a.to.y-uy*(nodeR+14);
      // Arrowhead
      const headLen=14, headW=7;
      const ax1=ex-ux*headLen+uy*headW, ay1=ey-uy*headLen-ux*headW;
      const ax2=ex-ux*headLen-uy*headW, ay2=ey-uy*headLen+ux*headW;

      const alpha = (1-t)*0.7; // fades to transparent

      // Shaft: white-bordered transparent line
      ctx.save();
      ctx.globalAlpha = alpha;
      // Outer stroke (white border)
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex-ux*headLen*0.5, ey-uy*headLen*0.5);
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=4; ctx.stroke();
      // Inner stroke (colored, thinner)
      ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex-ux*headLen*0.5, ey-uy*headLen*0.5);
      ctx.strokeStyle=a.color; ctx.lineWidth=2; ctx.stroke();
      // Arrowhead
      ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ax1,ay1); ctx.lineTo(ax2,ay2); ctx.closePath();
      ctx.fillStyle='#ffffff'; ctx.fill();
      ctx.fillStyle=a.color; ctx.globalAlpha=alpha*0.6; ctx.fill();
      ctx.restore();

      // Label at midpoint
      if (a.label){
        const mx=(sx+ex)/2 - uy*16, my=(sy+ey)/2 + ux*16; // offset perpendicular
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font='bold 18px "SF Mono",Consolas,monospace';
        ctx.fillStyle='#ffffff';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(a.label, mx, my);
        ctx.restore();
      }
    } else if (a.type==='production'){
      const s=35*(1-t);
      ctx.beginPath(); ctx.arc(a.x,a.y,s,0,2*Math.PI);
      ctx.strokeStyle='#3fb950'+fade; ctx.lineWidth=2.5; ctx.stroke();
      // Inner glow
      ctx.beginPath(); ctx.arc(a.x,a.y,s*0.5,0,2*Math.PI);
      ctx.strokeStyle='#3fb95044'; ctx.lineWidth=1; ctx.stroke();
    } else if (a.type==='capital'){
      const dx=a.to.x-a.from.x, dy=a.to.y-a.from.y;
      const bx=(a.from.x+a.to.x)/2 + (-dy*0.2);
      const by=(a.from.y+a.to.y)/2 + (dx*0.2);
      const px=(1-t)*(1-t)*a.from.x + 2*(1-t)*t*bx + t*t*a.to.x;
      const py=(1-t)*(1-t)*a.from.y + 2*(1-t)*t*by + t*t*a.to.y;
      ctx.beginPath(); ctx.arc(px,py,6,0,2*Math.PI);
      ctx.fillStyle='#d2a8ff'+fade; ctx.fill();
      for (let j=1;j<4;j++){
        const tt=Math.max(0,t-j*0.04);
        const tx=(1-tt)*(1-tt)*a.from.x+2*(1-tt)*tt*bx+tt*tt*a.to.x;
        const ty=(1-tt)*(1-tt)*a.from.y+2*(1-tt)*tt*by+tt*tt*a.to.y;
        ctx.beginPath(); ctx.arc(tx,ty,3,0,2*Math.PI);
        ctx.fillStyle='#d2a8ff44'; ctx.fill();
      }
    } else if (a.type==='merchant'){
      // Ship emoji sailing from center (abroad) to merchant node
      const dx=a.to.x-a.from.x, dy=a.to.y-a.from.y;
      const px=a.from.x + dx*t;
      const py=a.from.y + dy*t;
      ctx.save();
      ctx.globalAlpha = 1-t*0.3;
      ctx.font = '84px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('\u26F5', px, py);
      // Cargo label below ship
      if (a.label){
        ctx.font = 'bold 16px "SF Mono",Consolas,monospace';
        ctx.fillStyle = '#f0f6fc';
        ctx.fillText(a.label, px, py + 50);
      }
      ctx.restore();
    } else if (a.type==='produce_label'){
      // Floating upward label showing what was produced, anchored to owner's current position
      const owner = proprietors[a.ownerId];
      if (!owner) continue;
      const rise = 70 * t;
      const nodeR = Math.min(52, radius*0.34);
      const startY = owner.y - nodeR - 16;
      ctx.font='bold 24px "SF Mono",Consolas,monospace';
      ctx.fillStyle = a.color + fade;
      ctx.textAlign='center'; ctx.textBaseline='bottom';
      ctx.fillText(a.label, owner.x, startY - rise);
    }
  }

  // Proprietors
  for (const p of proprietors){
    const R = Math.min(52, radius*0.34);

    let bg='#161b22', border='#30363d';
    if (p.dead) { bg='#0d0d0d'; border='#4a2020'; }
    else if (mode==='expanded') {
      if (p.agentClass==='capitalist') { border='#ff9f43'; bg='#3d2200'; }
      else { border='#56d4dd'; bg='#0d2d30'; }
    }
    else if (p.role==='buyer')     {border='#58a6ff'; bg='#0d2240';}
    else if (p.role==='seller')    {border='#f0883e'; bg='#3d1f00';}
    else if (p.role==='producer')  {border='#3fb950'; bg='#0a3d1c';}
    else if (p.role==='capitalist'){border='#d2a8ff'; bg='#2d1a4e';}
    if (!p.dead && p.isCapitalist&&mode==='simple'){border='#d2a8ff'; bg='#2d1a4e';}

    ctx.beginPath(); ctx.arc(p.x,p.y,R,0,2*Math.PI);
    ctx.fillStyle=bg; ctx.fill();
    ctx.strokeStyle=border; ctx.lineWidth=p.dead?1.5:2.5; ctx.stroke();

    if (p.dead) {
      // Skull emoji + label
      ctx.font=`${Math.max(28,R*0.7)}px sans-serif`;
      ctx.fillStyle='#ffffff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('\uD83D\uDC80', p.x, p.y-R*0.1);
      ctx.font=`bold ${Math.max(14,R*0.36)}px Georgia`;
      ctx.fillStyle='#6e4444';
      ctx.fillText(p.label, p.x, p.y+R*0.5);
    } else {
      // Name
      ctx.font=`bold ${Math.max(22,R*0.58)}px Georgia`;
      ctx.fillStyle='#f8fafc'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.label, p.x, p.y-R*0.22);

      // Money (smaller, below name)
      ctx.font=`${Math.max(14,R*0.38)}px "SF Mono",Consolas,monospace`;
      ctx.fillStyle='#9dd3ff';
      ctx.fillText(`m=${p.money.toFixed(1)}`, p.x, p.y+R*0.22);

      // Class+dept label in expanded mode
      if (mode==='expanded' && p.department > 0) {
        const deptLabel = p.department===1 ? 'Dept I' : 'Dept II';
        ctx.font=`${Math.max(11,R*0.28)}px "SF Mono",Consolas,monospace`;
        ctx.fillStyle = p.agentClass==='capitalist' ? '#ff9f43' : '#56d4dd';
        ctx.fillText(deptLabel, p.x, p.y+R*0.55);
      }
      // Means of production indicator above capitalist nodes
      if (mode==='expanded' && p.agentClass==='capitalist') {
        const kQty = p.inventory['\u03C4'] || 0;
        if (kQty > DEATH_THRESHOLD) {
          ctx.font=`bold ${Math.max(18,R*0.44)}px "SF Mono",Consolas,monospace`;
          ctx.fillStyle='#e06c75'; ctx.textBaseline='bottom'; ctx.textAlign='center';
          ctx.fillText(`\u2699 ${kQty.toFixed(1)}\u03C4`, p.x, p.y-R-8);
        }
      }

      // Inventory arc segments (colored arcs proportional to share of each type)
      const entries = Object.entries(p.inventory).filter(([_, q]) => q > DEATH_THRESHOLD);
      const total = entries.reduce((s, [_, q]) => s + q, 0);
      if (total > 0) {
        let startAngle = -Math.PI / 2;
        for (const [sym, qty] of entries) {
          const sweep = (qty / total) * 2 * Math.PI;
          if (sweep < 0.02) { startAngle += sweep; continue; }
          ctx.beginPath();
          ctx.arc(p.x, p.y, R + 8, startAngle, startAngle + sweep);
          const ctype = typeBySymbol(sym);
          ctx.strokeStyle = ctype?.color || '#888';
          ctx.lineWidth = 6;
          ctx.stroke();
          startAngle += sweep;
        }

        // Total goods below node
        ctx.font=`${Math.max(20,R*0.42)}px Georgia`;
        ctx.fillStyle='#f5a76ecc'; ctx.textBaseline='top';
        ctx.textAlign='center';
        ctx.fillText(total.toFixed(1), p.x, p.y+R+13);
      }

      // Capital δ
      if (p.isCapitalist && p.capitalSurplus>0){
        ctx.font=`bold ${Math.max(22,R*0.48)}px "SF Mono",Consolas,monospace`;
        ctx.fillStyle='#e0bfff'; ctx.textBaseline='bottom';
        ctx.textAlign='center';
        ctx.fillText(`\u03B4=${p.capitalSurplus.toFixed(1)}`, p.x, p.y-R-8);
      }
    }
  }



  // Depletion warning
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (G<DEATH_THRESHOLD){
    ctx.font='bold 36px Georgia'; ctx.fillStyle='#ff6b6b';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('\u26A0  G \u2248 0 \u2014 Commodity depletion', cx, cy+56);
    ctx.font='24px Georgia'; ctx.fillStyle='#f5a76e';
    ctx.fillText('Circulation halted. Enable production to stabilize. \u00A79.10', cx, cy+92);
  }

  drawChart();
}

function drawChart(){
  const W = chartCanvas.width/DPR, H = chartCanvas.height/DPR;
  chartCtx.clearRect(0,0,W,H);
  chartCells = [];
  if (gHistory.length<2) return;

  // Dynamic grid layout
  const COLS = 3;
  const pad = {l:6, r:6, t:4, b:14};
  const cellPadL = 36; // left padding inside each cell for value label
  const cellPadR = 44; // right padding inside each cell for dual/owner labels
  const gapX = 8, gapY = 4;

  const allSeries = [
    { key:'goods',    data: gHistory,              color: '#f0883e', label: '|G| goods',      fmt: 1 },
    { key:'value',    data: vHistory,              color: '#79c0ff', label: 'V value',        fmt: 1 },
    { key:'share',    multi: true, datasets: ownerValueHistories, label: 'Value share %', fmt: 0 },
    { key:'produced', data: prodPerTickHistory,    color: '#3fb950', label: 'Produced/t',     fmt: 2 },
    { key:'consumed', data: consPerTickHistory,    color: '#da3633', label: 'Consumed/t',     fmt: 2 },
    { key:'arbitrage',data: arbCumHistory,     color: '#d2a8ff', label: 'Arbitrage \u03A3',   fmt: 1 },
    { key:'surplus',  data: surplusCumHistory, color: '#e06c75', label: 'Surplus val \u03A3', fmt: 1 },
    { key:'merchant', data: merchantCumHistory, color: '#ff9f43', label: 'Merchant \u03A3',   fmt: 1 },
    { key:'usury',    data: usuryCumHistory,    color: '#ffd700', label: 'Usury interest \u03A3', fmt: 1 },
    { key:'melt',     data: mevHistory,         color: '#58a6ff', label: 'MELT (V/M)',          fmt: 3 },
    { key:'deptI',    data: deptIOutputHistory,  color: '#e06c75', label: 'Dept I \u03C4/t',    fmt: 1 },
    { key:'deptII',   data: deptIIOutputHistory, color: '#3fb950', label: 'Dept II \u03C3/t',   fmt: 1 },
    { key:'profRate', data: profitRateHistory,   color: '#d2a8ff', label: 'profit rate',   fmt: 3 },
    { key:'capitalStock', data: capitalStockHistory, color: '#ff9f43', label: '\u03C4 stock', fmt: 1 },
    { key:'organicComp', data: organicCompHistory, color: '#56d4dd', label: 'c/v', fmt: 2 },
    { key:'kappa',    data: kappaHistory,        color: '#ffa060', label: '\u03BA accum', fmt: 3 },
    { key:'deptProfRates', dual: true, datasets: [profitRateIHistory, profitRateIIHistory],
      dualColors: ['#e06c75', '#3fb950'], dualLabels: ['r\u2081', 'r\u2082'], label: 'r\u2081 vs r\u2082', fmt: 3 },
    { key:'priceDev', dual: true, datasets: [priceDevTauHistory, priceDevSigHistory],
      dualColors: ['#ff69b4', '#bc8cff'], dualLabels: ['\u03C4', '\u03C3'], label: 'pp/val', fmt: 3, refLine: 1.0 },
    { key:'redist', dual: true, datasets: [normDevTauHistory, normDevSigHistory],
      dualColors: ['#ff69b4', '#bc8cff'], dualLabels: ['\u03C4', '\u03C3'], label: 'redist', fmt: 3, refLine: 1.0 },
  ];
  const modeFilter = CHART_SERIES.filter(cs => !cs.modes || cs.modes.includes(mode)).map(cs => cs.key);
  const series = allSeries.filter(s => chartVisible[s.key] && modeFilter.includes(s.key));

  const ROWS = Math.ceil(series.length / COLS);
  const totalW = W - pad.l - pad.r;
  const totalH = H - pad.t - pad.b;
  const cellW = (totalW - gapX * (COLS - 1)) / COLS;
  const cellH = (totalH - gapY * (ROWS - 1)) / ROWS;

  for (let s = 0; s < series.length; s++){
    const entry = series[s];
    const col = s % COLS;
    const row = Math.floor(s / COLS);
    const cx = pad.l + col * (cellW + gapX);
    const cy = pad.t + row * (cellH + gapY);
    const plotL = cx + cellPadL;
    const plotR = cx + cellW - cellPadR;
    const plotW = plotR - plotL;

    // Cell border
    chartCtx.strokeStyle = '#21262d'; chartCtx.lineWidth = 1;
    chartCtx.strokeRect(cx, cy, cellW, cellH);

    // Alternating subtle background
    if ((col + row) % 2 === 1){
      chartCtx.fillStyle = '#161b2233';
      chartCtx.fillRect(cx, cy, cellW, cellH);
    }

    const margin = cellH * 0.14;
    const plotH = cellH - 2 * margin;

    if (entry.multi) {
      const datasets = entry.datasets;
      if (!datasets.length || datasets[0].length < 2) {
        drawCellLabel(entry.label, '#8b949e', cx, cy, cellW);
        continue;
      }
      let globalMax = 0.1;
      for (const ds of datasets) {
        for (const v of ds) if (v > globalMax) globalMax = v;
      }
      const window = Math.floor(plotW);
      for (let o = 0; o < datasets.length; o++){
        const ds = datasets[o];
        const pts = ds.slice(-window);
        const step = plotW / Math.max(pts.length - 1, 1);
        const clr = OWNER_COLORS[o % OWNER_COLORS.length];
        chartCtx.beginPath();
        for (let i = 0; i < pts.length; i++){
          const x = plotL + i * step;
          const y = cy + margin + plotH - (pts[i] / globalMax) * plotH;
          i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
        }
        chartCtx.strokeStyle = clr; chartCtx.lineWidth = 1.2; chartCtx.stroke();
        // Owner label at right end
        const lastVal = pts[pts.length - 1];
        const lastY = cy + margin + plotH - (lastVal / globalMax) * plotH;
        chartCtx.font = '8px "SF Mono",Consolas,monospace';
        chartCtx.fillStyle = clr;
        chartCtx.textAlign = 'left'; chartCtx.textBaseline = 'middle';
        const cly = Math.max(cy + 5, Math.min(cy + cellH - 5, lastY));
        chartCtx.fillText('O'+(o+1), plotR + 2, cly);
      }
      drawCellLabel(entry.label, '#8b949e', cx, cy, cellW);
      // Record cell for tooltip (use first dataset)
      const mPts = datasets[0].slice(-window);
      const mStep = plotW / Math.max(mPts.length - 1, 1);
      chartCells.push({ plotL, plotR, cy, cellH, pts: mPts, step: mStep, label: entry.label, color: '#8b949e', fmt: entry.fmt, dataLen: datasets[0].length });
    } else if (entry.dual) {
      // Dual-line chart: two series on shared y-axis with optional reference line
      const { datasets: dualDs, dualColors, dualLabels, refLine } = entry;
      if (!dualDs[0].length || dualDs[0].length < 2) {
        drawCellLabel(entry.label, '#8b949e', cx, cy, cellW);
        continue;
      }
      const dualWin = Math.floor(plotW);
      // Compute shared min/max across both series
      let dMin = Infinity, dMax = -Infinity;
      const dualPts = [];
      for (const ds of dualDs) {
        const sl = ds.slice(-dualWin);
        dualPts.push(sl);
        for (const v of sl) { if (v < dMin) dMin = v; if (v > dMax) dMax = v; }
      }
      if (refLine !== undefined) { dMin = Math.min(dMin, refLine); dMax = Math.max(dMax, refLine); }
      const range = dMax - dMin || 0.001;
      // Add 5% padding
      dMin -= range * 0.05; dMax += range * 0.05;
      const dRange = dMax - dMin;

      // Reference line
      if (refLine !== undefined) {
        const ry = cy + margin + plotH - ((refLine - dMin) / dRange) * plotH;
        chartCtx.strokeStyle = '#30363d'; chartCtx.lineWidth = 1;
        chartCtx.setLineDash([3, 3]);
        chartCtx.beginPath(); chartCtx.moveTo(plotL, ry); chartCtx.lineTo(plotR, ry); chartCtx.stroke();
        chartCtx.setLineDash([]);
      }

      // Draw each line
      for (let d = 0; d < dualDs.length; d++) {
        const pts = dualPts[d];
        const step = plotW / Math.max(pts.length - 1, 1);
        const clr = dualColors[d];
        chartCtx.beginPath();
        for (let i = 0; i < pts.length; i++) {
          const x = plotL + i * step;
          const y = cy + margin + plotH - ((pts[i] - dMin) / dRange) * plotH;
          i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
        }
        chartCtx.strokeStyle = clr; chartCtx.lineWidth = 1.3; chartCtx.stroke();
        // Value label + series label at right
        const lastVal = pts[pts.length - 1];
        const lastY = cy + margin + plotH - ((lastVal - dMin) / dRange) * plotH;
        chartCtx.font = '9px "SF Mono",Consolas,monospace';
        chartCtx.fillStyle = clr;
        chartCtx.textAlign = 'left'; chartCtx.textBaseline = 'middle';
        const dly = Math.max(cy + 5, Math.min(cy + cellH - 5, lastY));
        const dValStr = entry.fmt === 0 ? String(Math.round(lastVal)) : lastVal.toFixed(entry.fmt);
        chartCtx.fillText(dualLabels[d] + ' ' + dValStr, plotR + 2, dly);
      }
      drawCellLabel(entry.label, '#8b949e', cx, cy, cellW);
      // Tooltip: store both datasets for dual display
      const dStep = plotW / Math.max(dualPts[0].length - 1, 1);
      chartCells.push({ plotL, plotR, cy, cellH, pts: dualPts[0], step: dStep, label: entry.label, color: '#8b949e', fmt: entry.fmt, dataLen: dualDs[0].length,
        dual: true, dualPts, dualColors, dualLabels });
    } else {
      const {data, color, label} = entry;
      if (data.length < 2) {
        drawCellLabel(label, color, cx, cy, cellW);
        continue;
      }

      const max = Math.max(...data, 0.001);
      const pts = data.slice(-Math.floor(plotW));
      const step = plotW / Math.max(pts.length - 1, 1);

      chartCtx.beginPath();
      for (let i = 0; i < pts.length; i++){
        const x = plotL + i * step;
        const y = cy + margin + plotH - (pts[i] / max) * plotH;
        i === 0 ? chartCtx.moveTo(x, y) : chartCtx.lineTo(x, y);
      }
      chartCtx.strokeStyle = color; chartCtx.lineWidth = 1.5; chartCtx.stroke();

      // Current value — left of plot area
      const last = pts[pts.length - 1];
      const lastY = cy + margin + plotH - (last / max) * plotH;
      chartCtx.font = '11px "SF Mono",Consolas,monospace';
      chartCtx.fillStyle = color;
      chartCtx.textAlign = 'right'; chartCtx.textBaseline = 'middle';
      const clampedY = Math.max(cy + 7, Math.min(cy + cellH - 5, lastY));
      const valStr = entry.fmt === 0 ? String(Math.round(last)) : last.toFixed(entry.fmt);
      chartCtx.fillText(valStr, plotL - 3, clampedY);

      drawCellLabel(label, color, cx, cy, cellW);
      chartCells.push({ plotL, plotR, cy, cellH, pts, step, label, color, fmt: entry.fmt, dataLen: data.length });
    }
  }

  // Shared time label at bottom-right
  chartCtx.font = '11px "SF Mono",Consolas,monospace'; chartCtx.fillStyle = '#8b949e';
  chartCtx.textAlign = 'right'; chartCtx.textBaseline = 'top';
  chartCtx.fillText(`t=${tick}`, W - pad.r, H - pad.b + 2);
}

function toggleChart(key){
  chartVisible[key] = !chartVisible[key];
  renderChartLegend();
  markPresetDirty();
}
function renderChartLegend(){
  const el = document.getElementById('chart-legend');
  const visible = CHART_SERIES.filter(s => !s.modes || s.modes.includes(mode));
  el.innerHTML = visible.map(s =>
    `<div class="legend-item${chartVisible[s.key]?'':' off'}" onclick="toggleChart('${s.key}')"><div class="legend-dot" style="background:${s.color}"></div> ${s.legendLabel}</div>`
  ).join('');
}

function drawCellLabel(label, color, cx, cy, cellW){
  chartCtx.font = '11px Georgia';
  chartCtx.fillStyle = color;
  chartCtx.textAlign = 'left'; chartCtx.textBaseline = 'top';
  chartCtx.fillText(label, cx + 4, cy + 2);
}

// ── Chart tooltip ──
let chartCells = [];  // populated by drawChart each frame
{
  const tooltip = document.getElementById('chartTooltip');
  chartCanvas.addEventListener('mousemove', (e) => {
    if (!chartCells.length) { tooltip.style.display = 'none'; return; }
    const rect = chartCanvas.getBoundingClientRect();
    // CSS px → canvas logical coords (drawChart uses canvas.width/DPR)
    const lx = (e.clientX - rect.left) * (chartCanvas.width / DPR) / rect.width;
    const ly = (e.clientY - rect.top) * (chartCanvas.height / DPR) / rect.height;

    for (const cell of chartCells) {
      if (lx >= cell.plotL && lx <= cell.plotR && ly >= cell.cy && ly <= cell.cy + cell.cellH) {
        const i = Math.round((lx - cell.plotL) / cell.step);
        const idx = Math.max(0, Math.min(cell.pts.length - 1, i));
        const tickNum = cell.dataLen - cell.pts.length + idx;
        const fmt = cell.fmt;
        if (cell.dual) {
          // Show both values with colored labels
          let html = `<span style="color:#8b949e">${cell.label} t=${tickNum}</span>`;
          for (let d = 0; d < cell.dualPts.length; d++) {
            const dIdx = Math.max(0, Math.min(cell.dualPts[d].length - 1, idx));
            const dVal = cell.dualPts[d][dIdx];
            const dStr = fmt === 0 ? String(Math.round(dVal)) : dVal.toFixed(fmt);
            html += `<br><span style="color:${cell.dualColors[d]}">${cell.dualLabels[d]} ${dStr}</span>`;
          }
          tooltip.innerHTML = html;
        } else {
          const val = cell.pts[idx];
          const valStr = fmt === 0 ? String(Math.round(val)) : val.toFixed(fmt);
          tooltip.textContent = `${cell.label}: ${valStr}  t=${tickNum}`;
          tooltip.style.color = cell.color;
        }
        // Position in CSS coords, clamped to chart bounds
        const tx = e.clientX - rect.left + 12;
        const ty = e.clientY - rect.top - 20;
        tooltip.style.left = Math.min(tx, rect.width - 160) + 'px';
        tooltip.style.top = Math.max(0, ty) + 'px';
        tooltip.style.display = '';
        return;
      }
    }
    tooltip.style.display = 'none';
  });
  chartCanvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
}

// ── Stats ──
function updateStats(){
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  const M = proprietors.reduce((s,p)=>s+p.money,0);
  const GV = proprietors.reduce((s,p)=>s+p.goodsValue(),0);
  document.getElementById('stat-tick').textContent = tick;
  document.getElementById('stat-G').textContent = G.toFixed(1);
  document.getElementById('stat-Mcirc').textContent = M.toFixed(1);
  document.getElementById('stat-Mtotal').textContent = GV.toFixed(1);
  document.getElementById('stat-exchanges').textContent = exchangeCount;
  document.getElementById('stat-productions').textContent = productionCount;
  document.getElementById('stat-surplus').textContent = surplusAccumulated.toFixed(1);
  document.getElementById('stat-surplus-labor').textContent = surplusLabor.toFixed(1);
  const mCum = merchantCumHistory.length ? merchantCumHistory[merchantCumHistory.length-1] : 0;
  document.getElementById('stat-merchant').textContent = mCum.toFixed(1);
  document.getElementById('stat-loans').textContent = loans.length;
  const uCum = usuryCumHistory.length ? usuryCumHistory[usuryCumHistory.length-1] : 0;
  document.getElementById('stat-usury').textContent = uCum.toFixed(1);

  // Expanded mode stats
  if (mode === 'expanded') {
    document.getElementById('dept-I-c').textContent = deptAccounting.I.c.toFixed(0);
    document.getElementById('dept-I-v').textContent = deptAccounting.I.v.toFixed(0);
    document.getElementById('dept-I-s').textContent = deptAccounting.I.s.toFixed(0);
    document.getElementById('dept-I-out').textContent = deptAccounting.I.output.toFixed(1);
    document.getElementById('dept-II-c').textContent = deptAccounting.II.c.toFixed(0);
    document.getElementById('dept-II-v').textContent = deptAccounting.II.v.toFixed(0);
    document.getElementById('dept-II-s').textContent = deptAccounting.II.s.toFixed(0);
    document.getElementById('dept-II-out').textContent = deptAccounting.II.output.toFixed(1);
    const tc = deptAccounting.I.c + deptAccounting.II.c;
    const tv = deptAccounting.I.v + deptAccounting.II.v;
    const ts = deptAccounting.I.s + deptAccounting.II.s;
    document.getElementById('dept-lambda').textContent = Math.round(expandedParams.accumRate * 100);
    // ε = δ/v (§17.5): surplus per unit variable capital (exploitation rate)
    const eps = tv > DEATH_THRESHOLD ? (ts / tv * 100) : 0;
    document.getElementById('dept-epsilon').textContent = eps.toFixed(1);
    // κ = λε (§22.2.4): actual accumulation rate from accounting data
    const kap = tv > DEATH_THRESHOLD ? (expandedParams.accumRate * ts / tv * 100) : 0;
    document.getElementById('dept-kappa').textContent = kap.toFixed(1);
    const oc = tv > DEATH_THRESHOLD ? (tc / tv) : 0;
    document.getElementById('dept-organic').textContent = oc.toFixed(2);
    document.getElementById('dept-pK').textContent = expandedPrices['\u03C4'].toFixed(1);
    document.getElementById('dept-pC').textContent = expandedPrices['\u03C3'].toFixed(1);
    // Per-department profit rates
    const rI = (deptAccounting.I.c + deptAccounting.I.v) > DEATH_THRESHOLD
      ? deptAccounting.I.s / (deptAccounting.I.c + deptAccounting.I.v) : 0;
    const rII = (deptAccounting.II.c + deptAccounting.II.v) > DEATH_THRESHOLD
      ? deptAccounting.II.s / (deptAccounting.II.c + deptAccounting.II.v) : 0;
    const rBar = (tc + tv) > DEATH_THRESHOLD ? ts / (tc + tv) : 0;
    document.getElementById('dept-profit-rates').textContent =
      'r\u2081=' + (rI*100).toFixed(1) + '% r\u2082=' + (rII*100).toFixed(1) + '% r\u0304=' + (rBar*100).toFixed(1) + '%';
    // Value prices for comparison when production prices are on
    const valLine = document.getElementById('dept-val-prices');
    if (expandedParams.prodPricesEnabled) {
      valLine.textContent = 'val: ' + valuePrices['\u03C4'].toFixed(1) + '/' + valuePrices['\u03C3'].toFixed(1);
      valLine.style.display = '';
    } else {
      valLine.style.display = 'none';
    }
  }
}

// ── Editable Leontief technology matrix ──
function renderEditableMatrix(){
  const el = document.getElementById('techMatrix');
  if(!el) return;
  const canRemove = TYPES.length > 1;
  let html = '';
  for (let j=0; j<LEONTIEF_RECIPES.length; j++){
    const r = LEONTIEF_RECIPES[j];
    const outT = TYPES.find(t=>t.sym===r.output);
    if(!outT) continue;
    const xw = PROD_WEIGHTS[j] !== undefined ? (PROD_WEIGHTS[j]*100).toFixed(0) : '?';
    const colSum = r.coeffs.reduce((s,c)=>s+c, 0);
    html += `<div class="tech-edit-row">`;
    html += `<span class="tech-edit-sym" style="color:${outT.color}">${outT.sym}</span>`;
    html += `<span class="tech-edit-arrow">\u2190</span>`;
    for (let k=0; k<r.inputs.length; k++){
      if(k>0) html += `<span class="tech-edit-plus">+</span>`;
      html += `<input type="number" min="0.05" max="0.95" step="0.05" value="${r.coeffs[k]}" onchange="onCoeffChange(${j},${k},this.value)" title="Input coefficient">`;
      html += `<select onchange="onInputChange(${j},${k},this.value)" title="Input commodity">`;
      for (const t of TYPES){
        html += `<option value="${t.sym}" ${t.sym===r.inputs[k]?'selected':''}>${t.sym}</option>`;
      }
      html += `</select>`;
    }
    html += `<span class="tech-count" title="equilibrium weight">x*${xw}%</span>`;
    html += `<button class="btn-remove" ${canRemove?'':'disabled'} onclick="removeCommodity(${j})" title="Remove commodity">\u2715</button>`;
    html += `</div>`;
  }
  // Column sum info
  if(LEONTIEF_RECIPES.length>0){
    const avgCS = LEONTIEF_RECIPES.reduce((s,r)=>s+r.coeffs.reduce((a,b)=>a+b,0),0)/LEONTIEF_RECIPES.length;
    const csClass = avgCS>=1 ? 'tech-col-sum-warn' : '';
    html += `<div class="tech-row" style="border-top:1px solid #30363d;margin-top:4px;padding-top:4px;">
      <span class="${csClass}" style="font-size:11px;">avg col \u03A3 = ${avgCS.toFixed(2)} \u2192 ${(1-avgCS).toFixed(2)} value-added</span>
    </div>`;
  }
  // Add button
  const canAdd = COMMODITY_POOL.some(c=>!TYPES.find(t=>t.sym===c.sym));
  html += `<button class="btn-add-commodity" ${canAdd?'':'disabled'} onclick="addCommodity()">+ Add Commodity</button>`;
  el.innerHTML = html;
}

function onCoeffChange(recipeIdx, inputIdx, value){
  const val = Math.max(0.05, Math.min(0.95, parseFloat(value)||0.4));
  const r = LEONTIEF_RECIPES[recipeIdx];
  const otherCoeff = r.coeffs[1-inputIdx];
  if(val+otherCoeff>=1){
    r.coeffs[inputIdx] = Math.round(Math.max(0.05, 0.99-otherCoeff)*100)/100;
  } else {
    r.coeffs[inputIdx] = Math.round(val*100)/100;
  }
  rebuildLeontief();
  resetSim();
}

function onInputChange(recipeIdx, inputIdx, sym){
  LEONTIEF_RECIPES[recipeIdx].inputs[inputIdx] = sym;
  rebuildLeontief();
  resetSim();
}

function addCommodity(){
  const available = COMMODITY_POOL.filter(c=>!TYPES.find(t=>t.sym===c.sym));
  if(!available.length) return;
  const newT = available[0];
  TYPES.push({name:newT.name, color:newT.color, sym:newT.sym});
  // Pick 2 random existing commodities as inputs (from the ones before this new one)
  const existing = TYPES.filter(t=>t.sym!==newT.sym);
  const inp1 = existing[Math.floor(Math.random()*existing.length)].sym;
  const inp2 = existing[Math.floor(Math.random()*existing.length)].sym;
  LEONTIEF_RECIPES.push({output:newT.sym, inputs:[inp1,inp2], coeffs:[0.4,0.4]});
  rebuildLeontief();
  resetSim();
}

function removeCommodity(idx){
  if(TYPES.length<=1) return;
  const removedSym = LEONTIEF_RECIPES[idx].output;
  TYPES.splice(idx,1);
  LEONTIEF_RECIPES.splice(idx,1);
  // Update any recipe that references the removed commodity as input
  for(const r of LEONTIEF_RECIPES){
    for(let k=0; k<r.inputs.length; k++){
      if(r.inputs[k]===removedSym){
        r.inputs[k] = TYPES[Math.floor(Math.random()*TYPES.length)].sym;
      }
    }
  }
  rebuildLeontief();
  resetSim();
}

function openLeontiefEditor(){
  document.getElementById('leontiefModal').classList.remove('hidden');
  renderEditableMatrix();
}
function closeLeontiefEditor(){
  document.getElementById('leontiefModal').classList.add('hidden');
}
function updateLeontiefSummary(){
  const el = document.getElementById('leontief-summary');
  if(!el) return;
  const avgCS = LEONTIEF_RECIPES.length>0
    ? LEONTIEF_RECIPES.reduce((s,r)=>s+r.coeffs.reduce((a,b)=>a+b,0),0)/LEONTIEF_RECIPES.length
    : 0;
  el.textContent = `${TYPES.length} commodities, avg col \u03A3 = ${avgCS.toFixed(2)}`;
}

function setCoupling(on){
  coupleExchangeConsumption = on;
  document.getElementById('btn-couple-on').className = on?'active':'';
  document.getElementById('btn-couple-off').className = on?'':'active';
  document.getElementById('coupling-desc').textContent = on
    ? 'Each exchange triggers consumption: buying drives using.'
    : 'Consumption and exchange are independent processes.';
  markPresetDirty();
}

// ── Log ──
function logEntry(type, msg){
  const log = document.getElementById('log');
  const e = document.createElement('div');
  e.className=`log-entry ${type}`;
  e.innerHTML=`<span class="time">t=${tick}</span>${msg}`;
  log.prepend(e);
  while (log.children.length>150) log.removeChild(log.lastChild);
}
function toggleLog(){
  const o = document.getElementById('logOverlay');
  o.classList.toggle('collapsed');
  document.getElementById('logToggle').textContent = o.classList.contains('collapsed') ? '\u25B6' : '\u25BC';
}
function copyLog(){
  const entries = document.querySelectorAll('#log .log-entry');
  const text = Array.from(entries).map(e => e.textContent).join('\n');
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('logCopy');
    btn.textContent = '\u2713';
    setTimeout(() => { btn.innerHTML = '\u2398'; }, 1200);
  });
}
function toggleLegend(){
  const o = document.getElementById('legendOverlay');
  o.classList.toggle('collapsed');
  document.getElementById('legendToggle').textContent = o.classList.contains('collapsed') ? '\u25B6' : '\u25BC';
}

// ── Controls ──
function setArbitrage(on){
  allowArbitrage = on;
  document.getElementById('btn-arb-on').className = on ? 'active' : '';
  document.getElementById('btn-arb-off').className = on ? '' : 'active';
  markPresetDirty();
}

function setMode(m){
  mode=m;
  document.getElementById('btn-mode-cc').className = m==='cc'?'active':'';
  document.getElementById('btn-mode-simple').className = m==='simple'?'active':'';
  document.getElementById('btn-mode-expanded').className = m==='expanded'?'active':'';
  const badge = document.getElementById('modeBadge');
  if (m==='cc'){ badge.className='mode-badge cc'; badge.textContent='Circulation \u00A79'; }
  else if (m==='simple'){ badge.className='mode-badge simple'; badge.textContent='Capital \u00A711\u201315'; }
  else { badge.className='mode-badge expanded'; badge.textContent='Reproduction \u00A722'; }
  document.getElementById('mode-desc').textContent = m==='cc'
    ? 'Commodity circulation C\u2192M\u2192C\u2032 with value-conserving production. \u00A79'
    : m==='simple'
    ? 'Capital circuit M\u2192C\u2192\u2026\u2192M\u2032 with surplus extraction \u03B4. \u00A711\u201315'
    : 'Total social capital \ud835\udca6 reproducing across Dept I (\u03C4) and Dept II (\u03C3). \u03B8-cycles. \u00A722';
  if (m==='simple') setProd('conservative');

  // Capital Forms group visibility
  const showForms = m==='simple';
  document.getElementById('section-capital-forms').style.display = showForms?'flex':'none';
  document.getElementById('capital-forms-divider').style.display = showForms?'block':'none';

  // Expanded params visibility
  const showExpanded = m==='expanded';
  document.getElementById('section-expanded-params').style.display = showExpanded?'flex':'none';
  document.getElementById('expanded-params-divider').style.display = showExpanded?'block':'none';

  // Hide/show sections and their dividers based on mode
  const expandedHidden = ['section-arbitrage','divider-arbitrage','section-production','divider-production',
    'section-coupling','divider-coupling','section-labor','divider-labor',
    'section-leontief','divider-leontief'];
  for (const id of expandedHidden) {
    const el = document.getElementById(id);
    if (el) el.style.display = showExpanded ? 'none' : (id.startsWith('divider') ? 'block' : 'flex');
  }

  // Reset controls when entering/leaving expanded mode
  if (showExpanded) {
    setArbitrage(false);
    // Enforce minimum 4 proprietors (2 capitalists + at least 2 workers)
    const propSlider = document.getElementById('numProprietors');
    if (+propSlider.value < 4) {
      propSlider.value = 4;
      document.getElementById('prop-count').textContent = '4';
    }
    propSlider.min = 4;
  } else {
    document.getElementById('numProprietors').min = 3;
  }

  // Disable all sub-modes when leaving simple/capital
  if (m!=='simple'){
    if (capitalSubModes.industrial) setIndustrialCapital(false);
    capitalSubModes.merchant = false;
    capitalSubModes.usury = false;
    capitalSubModes.industrial = false;
    document.getElementById('btn-merchant-on').className = '';
    document.getElementById('btn-merchant-off').className = 'active';
    document.getElementById('btn-usury-on').className = '';
    document.getElementById('btn-usury-off').className = 'active';
    document.getElementById('btn-industrial-on').className = '';
    document.getElementById('btn-industrial-off').className = 'active';
    document.getElementById('merchant-rates-container').style.display = 'none';
    document.getElementById('usury-settings').style.display = 'none';
    updateCapitalSubmodesDesc();
  }

  // Clamp t_r slider bounds by mode
  if (laborMode==='commodity') updateTrSlider();
  renderChartLegend();
  resetSim();
}

function setProd(p){
  prodMode=p;
  document.getElementById('btn-prod-off').className = p==='off'?'active':'';
  document.getElementById('btn-prod-conservative').className = p==='conservative'?'active':'';
  const descs = {
    off: 'No production. Circulation depletes G \u2192 0. §9.10.4',
    conservative: 'Leontief stabilizer: feedback controller drives |G| \u2192 target. Recipes from A, weighted by x*=(I\u2212A)\u207B\u00B9d. U(out)=U(in)/0.8 — labor adds 0.2 value. §9.12\u20139.14',
  };
  document.getElementById('prod-desc').textContent = descs[p] || '';
}

function toggleSection(id){
  document.getElementById(id).classList.toggle('section-collapsed');
}

function setLabor(m){
  laborMode = m;
  document.getElementById('btn-labor-implicit').className = m==='implicit'?'active':'';
  document.getElementById('btn-labor-commodity').className = m==='commodity'?'active':'';
  document.getElementById('labor-slider-group').style.display = m==='commodity'?'flex':'none';
  document.getElementById('labor-desc').textContent = m==='implicit'
    ? 'Each producer adds their own labor. No money exchanged for labor.'
    : 'Labor is a commodity: producers pay t\u1D63 to hire a laborer. Surplus s = value-added \u2212 t\u1D63 retained by producer.';
  updateTrSlider();
  markPresetDirty();
}

function updateTrSlider(){
  const slider = document.getElementById('trSlider');
  // Clamp bounds by mode
  const minVal = (mode==='simple' || mode==='expanded') ? 10 : 50;
  slider.min = minVal;
  if (+slider.value < minVal) slider.value = minVal;
  trRatio = +slider.value / 100;
  document.getElementById('tr-pct').textContent = slider.value;
  // Update description
  const pct = +slider.value;
  const desc = document.getElementById('tr-desc');
  if (pct >= 100) desc.textContent = 'Simple reproduction: t\u1D63 = value-added, no surplus (s=0).';
  else desc.textContent = `t\u1D63 = ${pct}% of value-added. Surplus s = ${100-pct}% retained by producer.`;
  markPresetDirty();
}

// ── Expanded parameter sliders ──
function updateAccumRate(){
  const v = +document.getElementById('accumRateSlider').value;
  expandedParams.accumRate = v / 100;
  document.getElementById('accum-rate-pct').textContent = v;
  markPresetDirty();
}
function updateExploitRate(){
  const v = +document.getElementById('exploitRateSlider').value;
  expandedParams.rateExploitation = v / 100;
  document.getElementById('exploit-rate-pct').textContent = v;
  markPresetDirty();
}
function updateWage(){
  const v = +document.getElementById('wageSlider').value;
  expandedParams.wagePerWorker = v;
  document.getElementById('wage-val').textContent = v;
  markPresetDirty();
}
function openExpandedParamsModal(){
  document.getElementById('expandedParamsModal').classList.remove('hidden');
  // Sync slider values
  document.getElementById('accumRateSlider').value = Math.round(expandedParams.accumRate * 100);
  document.getElementById('accum-rate-pct').textContent = Math.round(expandedParams.accumRate * 100);
  document.getElementById('exploitRateSlider').value = Math.round(expandedParams.rateExploitation * 100);
  document.getElementById('exploit-rate-pct').textContent = Math.round(expandedParams.rateExploitation * 100);
  document.getElementById('wageSlider').value = expandedParams.wagePerWorker;
  document.getElementById('wage-val').textContent = expandedParams.wagePerWorker;
  // Sync coefficient sliders from current recipes
  const rK = LEONTIEF_RECIPES.find(r=>r.output==='\u03C4');
  const rC = LEONTIEF_RECIPES.find(r=>r.output==='\u03C3');
  if (rK) { document.getElementById('coeffKISlider').value = rK.coeffs[0]; document.getElementById('coeff-ki-val').textContent = rK.coeffs[0]; }
  if (rC) { document.getElementById('coeffKIISlider').value = rC.coeffs[0]; document.getElementById('coeff-kii-val').textContent = rC.coeffs[0]; }
}
function closeExpandedParamsModal(){
  document.getElementById('expandedParamsModal').classList.add('hidden');
  if (mode === 'expanded') resetSim();
}
function updateExpandedCoeffs(){
  const ki = +document.getElementById('coeffKISlider').value;
  const kii = +document.getElementById('coeffKIISlider').value;
  document.getElementById('coeff-ki-val').textContent = ki.toFixed(2);
  document.getElementById('coeff-kii-val').textContent = kii.toFixed(2);
  const rK = LEONTIEF_RECIPES.find(r=>r.output==='\u03C4');
  const rC = LEONTIEF_RECIPES.find(r=>r.output==='\u03C3');
  if (rK) rK.coeffs[0] = ki;
  if (rC) rC.coeffs[0] = kii;
  computeExpandedPrices();
  markPresetDirty();
}

function toggleTechChange(){
  const on = document.getElementById('techChangeToggle').checked;
  expandedParams.techChangeEnabled = on;
  document.getElementById('tech-change-status').textContent = on ? 'on' : 'off';
  document.getElementById('techChangeRateGroup').style.display = on ? 'block' : 'none';
  // Lock coefficient sliders when technical change drives them
  document.getElementById('coeffKISlider').disabled = on;
  document.getElementById('coeffKIISlider').disabled = on;
}
function updateTechChangeRate(){
  const v = +document.getElementById('techChangeRateSlider').value;
  expandedParams.techChangeRate = v;
  document.getElementById('tech-change-rate-val').textContent = v.toFixed(3);
}

function toggleProdPrices(){
  const on = document.getElementById('prodPricesToggle').checked;
  expandedParams.prodPricesEnabled = on;
  document.getElementById('prod-prices-status').textContent = on ? 'on' : 'off';
}

function togglePlay(){
  playing=!playing;
  document.getElementById('btn-play').innerHTML = playing ? '\u23F8 Pause' : '\u25B6 Play';
  document.getElementById('btn-play').className = playing ? 'warn' : 'primary';
}
function stepOnce(){
  const G = proprietors.reduce((s,p)=>s+p.totalGoods(),0);
  if (G<DEATH_THRESHOLD){ logEntry('system','\u26A0 G\u22480 \u2014 cannot step, circulation halted.'); return; }
  step();
}
let _loadingPreset = false;
function resetSim(){
  playing=false;
  document.getElementById('btn-play').innerHTML='\u25B6 Play';
  document.getElementById('btn-play').className='primary';
  document.getElementById('log').innerHTML='';
  // Reset coefficient sliders to defaults (tech change will re-increment from here)
  const kiSl = document.getElementById('coeffKISlider');
  const kiiSl = document.getElementById('coeffKIISlider');
  if (kiSl) { kiSl.value = kiSl.defaultValue; document.getElementById('coeff-ki-val').textContent = (+kiSl.defaultValue).toFixed(2); }
  if (kiiSl) { kiiSl.value = kiiSl.defaultValue; document.getElementById('coeff-kii-val').textContent = (+kiiSl.defaultValue).toFixed(2); }
  resize(); init();
  if (!_loadingPreset) markPresetDirty();
}

// ── Loop ──
let lastStep=0;
function loop(ts){
  requestAnimationFrame(loop);
  const spd = +document.getElementById('speed').value;
  if (playing && ts-lastStep > 1000/spd){ step(); lastStep=ts; }
  draw();
}

window.addEventListener('resize', ()=>{ resize(); });

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left);
  const my = (e.clientY - rect.top);
  const radius = Math.min(canvas.width/(2*DPR), canvas.height/(2*DPR)) * 0.73;
  const hitR = Math.min(52, radius * 0.34) + 10;
  for (const p of proprietors) {
    if (p.dead) continue;
    const dx = mx - p.x, dy = my - p.y;
    if (dx*dx + dy*dy <= hitR*hitR) {
      const alive = proprietors.filter(q => !q.dead);
      const totalM = proprietors.reduce((s,q) => s + q.money, 0);
      const inject = Math.floor(totalM / alive.length);
      p.money += inject;
      logEntry('system', `\uD83D\uDCB5 Injected m=${inject} into ${p.label}`);
      updateStats();
      break;
    }
  }
});

// ── Presets (localStorage) ──
const PRESETS_KEY = 'sim-presets';
let activePresetName = null;  // currently loaded preset name (null = unsaved state)

function markPresetDirty(){
  if (activePresetName !== null) {
    activePresetName = null;
    renderPresetList();
  }
}

function getPresetState(){
  return {
    mode,
    prodMode,
    allowArbitrage,
    laborMode,
    trRatio,
    coupleExchangeConsumption,
    numProprietors: +document.getElementById('numProprietors').value,
    initCommodities: +document.getElementById('initCommodities').value,
    speed: +document.getElementById('speed').value,
    TYPES: TYPES.map(t=>({name:t.name, color:t.color, sym:t.sym})),
    LEONTIEF_RECIPES: LEONTIEF_RECIPES.map(r=>({output:r.output, inputs:[...r.inputs], coeffs:[...r.coeffs]})),
    capitalSubModes: {...capitalSubModes},
    capitalEligible: {
      merchant: [...capitalEligible.merchant],
      usury: [...capitalEligible.usury],
      industrial: [...capitalEligible.industrial],
    },
    merchantExchangeRates: {...merchantExchangeRates},
    usuryInterestRate,
    usuryInstallmentRatio,
    chartVisible: {...chartVisible},
    expandedParams: {...expandedParams},
    collapsedSections: ['section-stats','section-production','section-labor','section-presets']
      .filter(id => document.getElementById(id)?.classList.contains('section-collapsed')),
  };
}

function getAllPresets(){
  try { return JSON.parse(localStorage.getItem(PRESETS_KEY)) || {}; }
  catch(e){ return {}; }
}

function savePreset(name){
  if (!name){
    const input = document.getElementById('preset-name-input');
    name = input.value.trim();
    if (!name) return;
    input.value = '';
    document.getElementById('btn-save-preset').disabled = true;
  }
  const all = getAllPresets();
  all[name] = getPresetState();
  localStorage.setItem(PRESETS_KEY, JSON.stringify(all));
  activePresetName = name;
  renderPresetList();
}

function loadPreset(name){
  const all = getAllPresets();
  const s = all[name];
  if (!s) return;

  // Backward compat: 'capital' → 'simple'
  if (s.mode === 'capital') s.mode = 'simple';

  // Restore expanded params
  if (s.expandedParams) {
    expandedParams = {...expandedParams, ...s.expandedParams};
    expandedParams.numCapitalists = 2; // always fixed at 2
    document.getElementById('accumRateSlider').value = Math.round(expandedParams.accumRate * 100);
    document.getElementById('accum-rate-pct').textContent = Math.round(expandedParams.accumRate * 100);
    document.getElementById('exploitRateSlider').value = Math.round(expandedParams.rateExploitation * 100);
    document.getElementById('exploit-rate-pct').textContent = Math.round(expandedParams.rateExploitation * 100);
    document.getElementById('wageSlider').value = expandedParams.wagePerWorker;
    document.getElementById('wage-val').textContent = expandedParams.wagePerWorker;
  }

  // Restore TYPES and recipes before anything else (setMode may trigger resetSim)
  if (s.TYPES && s.TYPES.length > 0){
    TYPES = s.TYPES.map(t=>({name:t.name, color:t.color, sym:t.sym}));
    N_SECTORS = TYPES.length;
  }
  if (s.LEONTIEF_RECIPES) LEONTIEF_RECIPES = s.LEONTIEF_RECIPES.map(r=>({output:r.output, inputs:[...r.inputs], coeffs:[...r.coeffs]}));
  if (s.merchantExchangeRates) merchantExchangeRates = {...s.merchantExchangeRates};
  if (s.usuryInterestRate != null) usuryInterestRate = s.usuryInterestRate;
  if (s.usuryInstallmentRatio != null) usuryInstallmentRatio = s.usuryInstallmentRatio;

  // Sliders
  if (s.numProprietors != null){
    document.getElementById('numProprietors').value = s.numProprietors;
    document.getElementById('prop-count').textContent = s.numProprietors;
  }
  if (s.initCommodities != null){
    document.getElementById('initCommodities').value = s.initCommodities;
    document.getElementById('comm-count').textContent = s.initCommodities;
  }
  if (s.speed != null) document.getElementById('speed').value = s.speed;

  // Usury sliders
  document.getElementById('usuryRateSlider').value = Math.round(usuryInterestRate * 100);
  document.getElementById('usury-rate-pct').textContent = Math.round(usuryInterestRate * 100);
  document.getElementById('usuryInstallSlider').value = Math.round(usuryInstallmentRatio * 100);
  document.getElementById('usury-install-pct').textContent = Math.round(usuryInstallmentRatio * 100);

  // tr slider
  if (s.trRatio != null){
    trRatio = s.trRatio;
    document.getElementById('trSlider').value = Math.round(trRatio * 100);
  }

  // Toggles (order matters: setMode before capital sub-modes)
  if (s.coupleExchangeConsumption != null) setCoupling(s.coupleExchangeConsumption);
  if (s.allowArbitrage != null) setArbitrage(s.allowArbitrage);
  if (s.prodMode) setProd(s.prodMode);
  if (s.laborMode) setLabor(s.laborMode);

  // Mode (triggers resetSim internally)
  if (s.mode) setMode(s.mode);

  // Chart visibility
  if (s.chartVisible){
    for (const k of CHART_SERIES.map(c=>c.key)) chartVisible[k] = s.chartVisible[k] !== false;
    renderChartLegend();
  }

  // Sidebar collapsed sections
  if (s.collapsedSections){
    for (const id of ['section-stats','section-production','section-labor','section-presets','section-expanded-params']){
      const el = document.getElementById(id);
      if (!el) continue;
      if (s.collapsedSections.includes(id)) el.classList.add('section-collapsed');
      else el.classList.remove('section-collapsed');
    }
  }

  activePresetName = name;
  rebuildLeontief();
  _loadingPreset = true;
  resetSim();
  _loadingPreset = false;

  // Capital sub-modes + eligibility must come after resetSim since init() resets them
  if (s.capitalSubModes && s.mode === 'simple'){
    setMerchantCapital(!!s.capitalSubModes.merchant);
    setUsuryCapital(!!s.capitalSubModes.usury);
    setIndustrialCapital(!!s.capitalSubModes.industrial);
  }
  if (s.capitalEligible) {
    capitalEligible.merchant = new Set(s.capitalEligible.merchant || []);
    capitalEligible.usury = new Set(s.capitalEligible.usury || []);
    capitalEligible.industrial = new Set(s.capitalEligible.industrial || []);
    renderCapitalOwnerPickers();
  }

  renderPresetList();
}

function deletePreset(name){
  const all = getAllPresets();
  delete all[name];
  localStorage.setItem(PRESETS_KEY, JSON.stringify(all));
  renderPresetList();
}

function renderPresetList(){
  const el = document.getElementById('preset-list');
  const all = getAllPresets();
  const names = Object.keys(all);
  if (names.length === 0){ el.innerHTML = '<div class="desc">No saved presets.</div>'; return; }
  el.innerHTML = names.map(n => {
    const isActive = (n === activePresetName);
    const esc = n.replace(/'/g,"\\'");
    const escH = n.replace(/"/g,'&quot;');
    return `<div class="preset-item" style="${isActive?'background:#1f6feb22;border:1px solid #1f6feb44;':''}">
      <span class="preset-name" onclick="loadPreset('${esc}')" title="Load &quot;${escH}&quot;" style="${isActive?'color:#58a6ff;font-weight:700;':''}">${isActive?'\u25B8 ':''}${n}</span>
      <span style="display:flex;gap:2px;flex-shrink:0;">
        <button class="preset-delete" onclick="event.stopPropagation();savePreset('${esc}')" title="Update" style="color:#3fb950;">\u21BB</button>
        <button class="preset-delete" onclick="event.stopPropagation();deletePreset('${esc}')" title="Delete">&times;</button>
      </span>
    </div>`;
  }).join('');
}

// Render preset list and chart legend on load
renderPresetList();
renderChartLegend();

rebuildLeontief();
// Force-reset all modal inputs to HTML defaults (browser may cache form state)
(function syncFormState(){
  // Coefficient sliders
  const kiSl = document.getElementById('coeffKISlider');
  const kiiSl = document.getElementById('coeffKIISlider');
  if (kiSl) { kiSl.value = kiSl.defaultValue; document.getElementById('coeff-ki-val').textContent = (+kiSl.defaultValue).toFixed(2); }
  if (kiiSl) { kiiSl.value = kiiSl.defaultValue; document.getElementById('coeff-kii-val').textContent = (+kiiSl.defaultValue).toFixed(2); }
  // Accumulation, exploitation, wage sliders
  const accSl = document.getElementById('accumRateSlider');
  if (accSl) { accSl.value = accSl.defaultValue; updateAccumRate(); }
  const expSl = document.getElementById('exploitRateSlider');
  if (expSl) { expSl.value = expSl.defaultValue; updateExploitRate(); }
  const wageSl = document.getElementById('wageSlider');
  if (wageSl) { wageSl.value = wageSl.defaultValue; updateWage(); }
  // Technical change
  const tcCb = document.getElementById('techChangeToggle');
  if (tcCb) { tcCb.checked = false; toggleTechChange(); }
  const tcRate = document.getElementById('techChangeRateSlider');
  if (tcRate) { tcRate.value = tcRate.defaultValue; updateTechChangeRate(); }
  // Prices of production
  const ppCb = document.getElementById('prodPricesToggle');
  if (ppCb) { ppCb.checked = false; toggleProdPrices(); }
})();
resize(); init();
requestAnimationFrame(loop);

// ── _m ──
(function(){
  var _d=function(b){return decodeURIComponent(escape(atob(b)))};
  var _1=_d('wqkgMjAyNSBZdWFuIFlhbyAmIEdhYnJpZWwgVHVwaW5hbWLDoQ==');
  var _2=_d('IMK3IER5bmFtaWMgbW9kZWwgZm9yIDxpPkEgUHJpbWVyIG9uIFBoZW5vbWVub2xvZ2ljYWwgUG9saXRpY2FsIEVjb25vbXk8L2k+');
  var _t=_1+_2;
  var _i=function(){
    if(document.getElementById('_m'))return;
    var e=document.createElement('div');e.id='_m';e.innerHTML=_t;
    var h=document.querySelector('header');
    if(h)h.appendChild(e);
  };
  _i();
  new MutationObserver(_i).observe(document.body,{childList:true,subtree:true});
  setInterval(_i,4000);
})();
</script>
</body>
</html>
